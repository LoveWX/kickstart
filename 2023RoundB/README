Problem A. Collecting Pancakes
一些煎饼堆排成一行，给定每堆煎饼的数量。
A和B两人轮流行动，第一轮时，A标记的下标要在[La,Ra]中；B标记的下标要在[Lb,Rb]中
之后的每一轮，A或B只能标记紧邻己方的已标记堆且没有标记的煎饼堆。如果不能标记就跳过本轮
如果双方都按最优策略选择，求A能标记的最多煎饼数量。
对双方来说，最优选择是先扩展己方标记向对方靠拢，再标记远离对方的一端的标记
因此对于B来说，第一步需要尽可能紧贴A的第一步。
如果A确定了第一步，最优策略下最终状态就确定了。因此遍历A的第一步即可
如果A1<Lb，则B1=Lb；如果Rb<A1，则B1=Rb；否则B1为A1-1和A1+1中的较优者，如果能取到的话
利用前缀和即可快速计算。时间复杂度为O(N)

Problem B. Intruder Outsmarting
密码锁有W个表盘排成一排，每个表盘上有1~N共N个数字组成一个环。
每次操作可以转动一个表盘上的数字恰好D的距离，即x->(x+D)%N或者x->(x-D+N)%N
如果表盘上的数字形成回文串，则解锁成功
给定表盘上初始时的数字，求解锁需要的最少操作数
由于最终状态为回文，因此每个表盘最多只和另一个表盘对应，需要操作将两个表盘调一致
可以只操作一个表盘使其读数和另一个表盘一致。
设两个表盘A,B的初始读数为a,b，操作次数为x，向大方向拨表盘，则有：
a+Dx≡b(mod N) -> a+Dx+Ny=b -> Dx+Ny=b-a  (1)
而向小方向拨表盘则有：
a−Dx≡b(mod N) -> a−Dx+Ny=b -> Dx−Ny=a−b  (2)
这是线性丢番图方程/裴蜀等式：ax+by=m，令d=gcd(a,b)
如果m%d!=0，那么裴蜀等式无解，原问题也无解。
可以通过扩展欧几里德算法得到方程ax+by=gcd(a,b)的特解{x0,y0}，进而得到裴蜀等式的通解：
x=m/d*x0+k*b/d, y=m/d*y0-k*a/d, d=gcd(a,b)  (3)
注意这里的gcd是带符号的，而c++17中提供的gcd是无符号的，可以直接用扩展欧几里德算法求得的gcd
注意这里求得的通解是(x+k×N/d,y−k*D/d),k为任意整数
而x表示操作次数，需要求最小的正整数，因此xmin=x%N/d
注意可以向两个方向波动表盘，因此需要通过式(1)和式(2)求得较小值。
累加回文对应的各个表盘的结果即为所求。
由于扩展欧几里德算法时间复杂度为O(logn)，因此总时间复杂度为O(W*log(min(D,N)))

Problem C. Spacious Sets
如果一个集合S中任意两个元素x,y都有|x-y|>=K，则认为该集合是“宽敞”的
给定集合S和K，对于S中的每一个元素Ai，求包含Ai的集合S的宽敞子集的最大容量
如果是求集合S的最大宽敞子集的容量，那么可以用dp计算
设dp(i,0)为[A0,...,Ai]中不包括Ai的宽敞子集的最大容量；
dp(i,1)为[A0,...,Ai]中包括Ai的宽敞子集的最大容量，因此有：
dp(i,0)=max(dp(i-1,0),dp(i-1,1))
dp(i,1)=1+dp(i-1,0)
注意到这里集合S是排序的，这种方法从小到大进行计算，
而中间结果dp(i,1)即为“包含Ai的左侧最大宽敞子集的容量”。
同理可以从大到小进行计算，求出"包含Ai的右侧最大宽敞子集的容量"
两者的和减去重复计算的Ai，即为包含Ai的集合S的最大宽敞子集的容量
需要使用排序的数组代替集合进行计算，排序需要O(NlogN)的时间，两次dp都需要O(N)的时间
因此总时间复杂度为O(NlogN)

Problem D. Railroad Maintenance
有N个车站组成一个连通图，共有L个线路，每个车站至少属于一个线路，每个线路相当于连通图中的简单路径。
如果从一个车站出发经过任意次换乘到达另一个车站，则说明这两个车站是连通的。
对于某个线路来说，如果单独关闭，则不能换乘这个线路。
如果这样可能造成有些车站间无法到达，则成该线路为"关键"线路。求关键线路的个数
可以将"线路"理解为一个"超点"，这样方便在图上表达线路的概念。
但是车站却不能理解为"超边"，而是需要对每个线路另外新建一个"超点"，使其与线路中所有的点有边连接
同时，原图中不存在原来的边。新图仍然是连通的
这样，就将"线路"的概念凝聚到了"超点"上，线路对应的超点之间通过原图的点(车站)来连接。
对某个线路对应的超点而言，如果去掉这个超点之后，图不连通了，那么该超点即为关键线路。
因此只要在新图中求出割点即可。
新增了L个超点和K条边，总时间复杂度为O(N+K)

Problem E. Railroad Maintenance
有N个站点，第i个站点计划向其它一个站点Di发出一趟Ci个货物。
在计划开始前，可以向任意站点补充任意个货物。所有运输计划的先后是可以调整的。
对每个站点而言，如果在出发前已经收到了其它站点的货物，
那么这些货物可以用于该站点发送给它的目的站点，而不用事先补充。
求总共最少需要向这N个站点补充多少货物。
将每个站点看成点，向另一个站点运输货物看作边，边权值为Ci。这样就构成了一个有向图
如果一个站点没有入边，则表示没有其它站点给它补充货物，因此它发出的所有货物都依赖事先补充。
可以用类似拓扑排序的方法，计算这个没有入度的点，更新到它的下一个点，然后将该点和它的出边删除
这样有向图中可能剩下一些环，这些环之间互相不会干扰，可以依次求解。
需要尝试将环中的每个点作为起点遍历整个环求出需要补充的总量。
对于第i个站点而言，设R[i]为它在前述去边的过程中获得的货物，则其需要补充的货物为：
i是起点:   max(C[i]-R[i]),  (1)
i不是起点: max(C[i]-(C[prev[i]]+R[i]),0),  (2)
可以先对所有点求出式(2)的总和，再以各个点为起点，将其对应的值从式(2)更新为式(1)，找出最小值。
前述去边过程中补充的货物与各个环补充货物的总和即为所求
拓扑排序去边的时间复杂度为O(去掉点的个数)，每个环找到最小值的时间复杂度为O(环上点的个数)
因此，总时间复杂度为O(N)

