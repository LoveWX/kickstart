Problem A. Colliding Encoding
给定一个大写英文字母A~Z到数字0~9的转换表，以及一些不同的单词。
将每个单词的每个英文字母转换为数字，求是否会有不同的单词转换为同样的数字串。
按表转换每个单词并保存每个数字串到集合中，如果集合大小小于单词表大小则表示有冲突。

Problem B. Illumination Optimization
给出线段[0,M]，在线段上一些整数点上有一些灯泡，并给出它们的坐标:X1,X2,...Xn
每个灯泡可以照亮[X-R,X+R]的范围。求要照亮整个线段[0,M]，不仅仅是整数点，至少需要打开多少个灯泡。
每个灯泡可以看作长度为2R的线段，需要用最少的线段来覆盖。
可以从左向右考虑，设Right为目前到达的右端点，即[0,Right]的线段已经被覆盖了
贪心地选择某个未使用的线段[a,b]使得其左端点能够覆盖到点Right即可，即:a<=Right
因为如果此时的最优线段是[c,d]，且c<=Right,d<b，那么将[c,d]替换为[a,b]，使用数量不变，但是照明的范围更大
由于灯泡位置已经排序，只需遍历一次即可，时间复杂度为O(N)

Problem C. Rainbow Sort
有N张牌排成一排，每张牌有一种颜色，可以有多张牌有同样的颜色。
现在需要从左到右依次给这些牌写一个数字，需要满足这些条件
1.这些数字从左到右组成的数列是非递减的
2.同样颜色的牌上的数字相同
3.不同颜色的牌上的数字不同
依照每种颜色的牌上的数字排序颜色并从小到大输出每种颜色
观察条件可知每种颜色的牌需要挨在一起，否则就不满足条件
反设两张牌A(颜色为A,值为a)之间有一张牌B(颜色为B,值为b)，
则对于第一张牌A和牌B来说，由条件1得a<=b；由条件3得a!=b；因此a<b
而对于牌B和第二张牌A来说，由条件1得b<=a；由条件3得b!=a；因此b<a
因此矛盾。所以相同颜色的牌一定相邻
而所有的牌排序时的关键字是写上的数字，这些数字组成的数组本身是非递减的
因此只需要将每种颜色按输入顺序输出即可，每种颜色最多只输出一次。时间复杂度为O(N)

Problem D. ASCII Art
用代码打印字符串：
for i = 1 to 1e100:
  for letter = A to Z:
    print letter i times
即对每个i，依次打印'A'-'Z'，每个字母打印i次。求该字符串的第N个字符
可以将每个i对应的下标区间求出来，这样大约有sqrt(N)个区间。注意到N<=1e12，因此大约需要求1e6个区间
求出N所在的区间的起点之后，N和起点的差值d即为N在该段中的偏移，N即为字母表中第d/i个字符
需要先求出所有的区间的起点，时间复杂度为O(sqrt(N))
对于每个输入需要用二分查找所在的区间并计算位置，时间复杂度为O(logM),M为区间个数,M~O(sqrt(N))

Problem E. Untie
N个人坐成一个圈玩石头剪刀布，每个人只和他相邻的两个人比较。他们同时出手后，可能有一些相邻的两人是平局。
求至少需要改变几个人的出手使得每对相邻的两人不会有平局。
由于每个人都只和两人相邻，而出手有三种，因此一个人总能够将出手修改为和邻居不同的状态
对于圈上共M个人且出手相同的一段，只要间隔一个人修改状态即可。即需要修改floor(M/2)个状态
特殊地，如果N个人的出手一致，那么所求的段是首位相接的，当N为奇数时就需要多修改一个状态，因此为floor((M+1)/2)
由于输入数组表示的是一个圈，可以先计算跨越数组首尾的那一段，破圈之后再将剩余部分当作一个线段来处理
时间复杂度为O(N)
