Problem A. H-index
H-index是指在正整数数组中有H个数其值大于等于H。每次给出数组中的一个数，求给出这个数后现有数组的H-index
设数组中大于等于H的数组成集合S
将数组排序，并用柱状图表示，则H-index表示在右下角最大正方形的边长。正方形的底表示集合S的size，高表示集合S的最小值。
如果S.size>S.minval，需要去掉S中的最小值，使得S.size变小S.minval变大。
直到S.size<=S.minval，说明已经找到这个正方形，此时H=min(S.size,S.minval)=S.size
维护一个小顶堆来表示集合S，每当给出一个数a时就加入集合S中，重复上述步骤找到H-index
如果a<=H，则a<=S.size<S.size+1，所以a将作为集合S的最小元素首先被剔除
如果a>H，则集合S的容量增加1
时间复杂度为O(NlogN)

Problem B. Diagonal Puzzle
N*N矩阵中每个格点为黑色或者白色，一次操作可以将任一对角线上的所有格点翻转颜色。给定初始矩阵时将矩阵变为全黑最少需要多少次操作
可以观察到这些性质：
1.每个对角线只可能翻转0次或1次
2.将点(0,0)沿对角线扩展，遇到的所有点为一组，剩余所有点为另一组，这样整个矩阵被划分为棋盘状。
一组点的状态不会影响到另一组点的状态，因此可以分开考虑两组点，对角线也因此划分为两组。
3.如果某个对角线确认是否翻转，那么该对角线所在的组中所有点的状态都可以确认。
方法一：
尝试主对角线翻转/不翻转两种情况，这样主对角线可以确定状态，如果其上的点仍有白色，那么一定是通过该点的另一对角线翻转了
这样就可以确定该组对角线中与副对角线平行的对角线，再检查其它与主对角线平行的对角线，就能得到确定的状态
注意最后检查的与主对角线平行的对角线上可能需要再翻转一次，也可能出现冲突。
另一组点可以用类似的方法求解，注意N为奇数时主对角线和副对角线在同一组中，需要选择与副对角线平行的次长的对角线
时间复杂度为O(N^2)
方法二：
将格点转换为无向图，每个对角线视为顶点，原矩阵每个格点视为边，每个边只连接两个格点
用顶点染色代替对角线翻转，原问题即转化为2-着色问题，但是附加了一些约束：
白色边表示其连接的两个顶点颜色不同，表示需要翻转该边对应点的一条对角线使其变为黑色
黑色边表示其连接的两个顶点颜色相同，表示不需要翻转
这样可以用dfs求解，时间复杂度为O(N^2)
其实这两种方法本质是一样的，都是利用性质3尝试确定某一对角线后确定其它对角线。
方法一选择了影响最大的主副对角线开始，使得dfs递归树较矮，可以在3步内完成类似方法二递归的操作。

Problem C. Elevanagram
正整数能被11整除的速判法是，将各个数位视作单个数字，最高位为正，依次加减各个数位，如果结果能够被11整除，则原数能被11整除
给出一个数字(不含0)包含的1-9的个数，求是否可以组成被11整除的数
原题即为将所有数字分成两组，正数组P和负数组N，使得正数组和减去负数组和为11的倍数
从1到9依次处理每一种数字，设dp[i][j][k]表示在[1,i]的所有数字中，正数组中包含j个数时，总和模11的余数是否可以达到
时间复杂度为O(9*sum(Ai)*11*max(Ai))，可以通过小数据
大数据集可以有几个推论：
1.如果有两个数的个数大于等于10个，则必定可以组成。
设1<=i<j<=9，且A[i]>=10，A[j]>=10，那么取10个i和10个j组成集合S，将剩下的所有元素随意均分为两半。
从S中选p个i和10-p个j放入P中，将S中剩下的10-p个i和p个j放入N中（0<=p<=10）
在p从0遍历到10的过程中，sum(P)-sum(N)每次都增加(j-i)*2，由于(j-i)*2与11是互质的，因此[sum(P)-sum(N)]%11遍历了[0,10]的所有值。
2.将数的个数模22是不对的，反例：0 0 0 0 2 0 1 1 22
3.大部分解法均认为如果一个数的个数超出一定值就只取这个值，当然还要保持奇偶性
大多数都认为如果A[i]>=22，则A[i]=20+A[i]%2
https://codeforces.com/blog/entry/71373 也是这么讨论的
但是按照sum list的说法，并不需要A[i]>=22，只要A[i]>=11即可
而且即使sum list能够取到[0,10]的每个值，但进入正数组P的个数并不一样，不知该如何证明
