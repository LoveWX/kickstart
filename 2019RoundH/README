Problem A. H-index
H-index是指在正整数数组中有H个数其值大于等于H。每次给出数组中的一个数，求给出这个数后现有数组的H-index
设数组中大于等于H的数组成集合S
将数组排序，并用柱状图表示，则H-index表示在右下角最大正方形的边长。正方形的底表示集合S的size，高表示集合S的最小值。
如果S.size>S.minval，需要去掉S中的最小值，使得S.size变小S.minval变大。
直到S.size<=S.minval，说明已经找到这个正方形，此时H=min(S.size,S.minval)=S.size
维护一个小顶堆来表示集合S，每当给出一个数a时就加入集合S中，重复上述步骤找到H-index
如果a<=H，则a<=S.size<S.size+1，所以a将作为集合S的最小元素首先被剔除
如果a>H，则集合S的容量增加1
时间复杂度为O(NlogN)

Problem B. Diagonal Puzzle
N*N矩阵中每个格点为黑色或者白色，一次操作可以将任一对角线上的所有格点翻转颜色。给定初始矩阵时将矩阵变为全黑最少需要多少次操作
可以观察到这些性质：
1.每个对角线只可能翻转0次或1次
2.将点(0,0)沿对角线扩展，遇到的所有点为一组，剩余所有点为另一组，这样整个矩阵被划分为棋盘状。
一组点的状态不会影响到另一组点的状态，因此可以分开考虑两组点，对角线也因此划分为两组。
3.如果某个对角线确认是否翻转，那么该对角线所在的组中所有点的状态都可以确认。
方法一：
尝试主对角线翻转/不翻转两种情况，这样主对角线可以确定状态，如果其上的点仍有白色，那么一定是通过该点的另一对角线翻转了
这样就可以确定该组对角线中与副对角线平行的对角线，再检查其它与主对角线平行的对角线，就能得到确定的状态
注意最后检查的与主对角线平行的对角线上可能需要再翻转一次，也可能出现冲突。
另一组点可以用类似的方法求解，注意N为奇数时主对角线和副对角线在同一组中，需要选择与副对角线平行的次长的对角线
时间复杂度为O(N^2)
方法二：
将格点转换为无向图，每个对角线视为顶点，原矩阵每个格点视为边，每个边只连接两个格点
用顶点染色代替对角线翻转，原问题即转化为2-着色问题，但是附加了一些约束：
白色边表示其连接的两个顶点颜色不同，表示需要翻转该边对应点的一条对角线使其变为黑色
黑色边表示其连接的两个顶点颜色相同，表示不需要翻转
这样可以用dfs求解，时间复杂度为O(N^2)
其实这两种方法本质是一样的，都是利用性质3尝试确定某一对角线后确定其它对角线。
方法一选择了影响最大的主副对角线开始，使得dfs递归树较矮，可以在3步内完成类似方法二递归的操作。

Problem C. Elevanagram
