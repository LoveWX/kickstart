Problem A. Password Attacker
求恰好包含m个字符长度为n的字符串的个数。
设所求为F(n,m)。对于m种字符，分成m-1种和1种字符来考虑。前m-1种字符在n的长度中最少占据m-1位，最多占据n-1位，那么从n个位置中选出前m-1种字符的位置，问题规模即从m变为m-1
F(n,m)=sum{F(i,m-1)*C(n,i)},i=n-1,n-2,...,m-1

Problem B. New Years Eve
1个酒杯放在3个品字形排列的酒杯上，由此组成L层的阵列，每层酒杯按每行每列编号。每个酒杯250ml，满之后溢出液体平均流入其下方的3个酒杯中。求倒入第1层第1个酒杯一定量酒之后，第L层第N个酒杯中的酒的量。
可以逐层计算每个酒杯的注入量和溢出量，但是大数据层数太多，需要用DP的方式只计算用到的酒杯。
对于第L层第N个酒杯，先通过N计算出在第L层中的行号r和列号c，累加第L-1层中的第(r,c),(r-1,c),(r-1,c-1)个的溢出量作为注入量，再计算溢出量。

Problem C. Card Game
数组中包含一些数，每次可以删掉相邻的3个数a,b,c，且须满足c-b=b-a=k。删掉这3个数后其前后的两个数变为相邻。求数组能剩下的最少的数的个数/最多能删掉的数的个数。
难点在于删掉3个数后原数组会缩短。对于原数组A[0,...,n-1]，设dp(left,right)为A[left]到A[right]这一段最多能删掉的元素个数，包含A[left]和A[right]。
对于A[left]到A[right]这一段，第一个元素可能不删除，此时结果为dp(left+1,right)；也可能删除，这时通过k计算第2个第3个元素的值并在[left,right]中遍历，如果第1第2元素之间包含元素个数是3的倍数，并且能够全部删掉；且第2第3元素之间包含元素个数是3的倍数，并且能够全部删掉，则为一种可行解。最大值即为当前dp(left,right)的解。

Problem D. Parentheses Order
n对左右括号组成的所有合法字符串，按字典序排序后，求第k个字符串。
n对左右括号组成的合法字符串数可由catalan数计算，但是一般地catalan数的生成方式却不符合字典序，比如n个点的二叉树的个数，需要用DP。
由于只有两种字符，又需要在字典序序列中找字符串，所以从第一个字符开始依次枚举左括号和右括号。
字符串可以看做 前缀+当前字符('('或者')')+后缀 的形式，对于特定前缀，计算前缀+'('时后缀的可能数量，即可确定当前位填'('还是')'
所以设dp的状态dp(n,m)为包含n个左括号m个右括号的后缀字符串的个数。注意是后缀字符串，所以n<=m，当n>m时，dp(n,m)=0
所以递推关系为dp(n,m)=dp(n-1,m)+dp(n,m-1)
