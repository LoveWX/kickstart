Problem A. Smaller Strings
用字母表前K个字母组成长度为N的字符串，求其中字典序小于给定的字符串S的回文字符串个数
回文字符串只要考虑S前一半字符串即可
对于左半边字符串Sl=Si,Si-1,...,S0，
对于第i位，如果新串该位小于Si，则其地位可以为任意值；否则考虑第Si-1位。可以表示为：
F(Si,Si-1,...,S0)=(Si-'A')*26^i+F(Si-1,...,S0)
从S中间向左依次计算即可。注意需要特判和S左半边一样的新串是否合法

Problem B. Alien Generator
正整数数列为K,K+1,...,K+i-1，总和恰为G，求数列有多少种可能
如果数列长度a为奇数，中位数为b，则有a*b==G，数列为[b-a/2,b+a/2]
对每一对c,d,c*d==G，检查长度c是否为奇数，最小值d-c/2是否是正整数。交换c,d，检查d和c-d/2
如果数列长度b为偶数，两个中位数的和为奇数a，则有a*b==G，数列为[a/2-b+1,a/2+b]
对每一对c,d,c*d==G，中位数之和c是否为奇数，最小值c/2-d+1是否为正整数。交换c,d，检查d,d/2-c+1

Problem C. Rock Paper Scissors
和对手玩石头剪刀布，单局胜可得W积分，平可得E积分，负不得分。每天玩60局。
已知对手的策略为：第一局随机出，之后的每一局按照当天自己所出拳的个数:石头R 布P 剪刀S加权平均分配概率出克制的拳。
即之前所有局中出拳个数为：R,P,S，则本局中对手将以R/(R+P+S)出P，以P/(R+P+S)出S，以S/(R+P+S)出R
制定一个出拳序列使得得分的数学期望最高。
用v[r][p][s]表示包括本局在内已经出了R共r次，P共p次，S共s次时，所能获得的最大数学期望。
则按本局的出拳共有3个其它状态可以转移到本局的(r,p,s)状态：
如果本局出R，则得分的数学期望为：v[r−1][p][s]+p/(n−1)*W+s/(n−1)*E
其中v[r−1][p][s]为前一个状态的数学期望
之前自己出P的概率为p/(n−1)，所以本局对手出S的概率为p/(n−1)，本局中自己出R获胜得分的数学期望为：p/(n-1)*W
同理可得本局出R平局得分的数学期望为s/(n−1)*E
同理可以推出本局出P得分的数学期望为：v[r][p−1][s]+s/(n−1)*W+r/(n−1)*E
本局出S得分的数学期望为：v[r][p][s−1]+r/(n−1)*W+p/(n−1)*E
所以v[r][p][s]应为这三者的最大值。
初始状态为v[1][0][0]=v[0][1][0]=v[0][0][1]=1/3
这样，每一个r+p+s==60的状态即为最终状态，它们中的最大值即为得分数学期望的最大值
在状态转移时，除了记录下最大得分的数学期望，也要记录下是取那个值得到的，这样就可以反推出整个出拳序列

Problem D. Binary Operator
给一些表达式，操作符只有+,*,#，其中+表示加法，*表示乘法，#表示任意一个全函数
求可以将这些表达式分为几个等价类，每个表达式在哪个等价类中
一个表达式可以转换为中缀树，每个非空子树的根节点是操作符，左右子节点为操作数或者另一个操作符
可见，如果某个子树中只有+,*，则该子树可以求值；如果有#，那么以#为根的子树是无法求值的，即使其可能包含可求值的其它子树
可以将以#为根的子树视作变量，每种不一样的树对应不同变量，这样可以在所有表达式中将#式用变量替代
这样，所有的表达式都变为了多项式，化简多项式，即可进行分类
注意操作数0在加法+和乘法*中的作用，注意操作数1在乘法*中的作用。注意本题中需要使用大数乘和大数加。
