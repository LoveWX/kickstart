Problem A. 

Problem B. Sherlock and Matrix Game
求N*N的矩阵中第K大的子矩阵和。N<=1e5
暴力遍历所有的子矩阵和时间复杂度为O(n^4)，小数据也会超时。
好在只需要求第K大的子矩阵和，所以需要分析第K大的子矩阵和的来源，保留必要的数据即可。
1.子数组和与子矩阵和
矩阵是由两个长度为N的数组相乘得到的，设矩阵中每个值M(i, j) = Ai * Bj
则对于左上顶点为(a,b)右下顶点为(c, d)的子矩阵而言,其子矩阵和为 (Aa + Aa+1 + ... + Ac) * (Bb + Bb+1 + ... + Bd)
这样就把子矩阵和转换为两个子数组和的乘积。
所以首先需要先求出两个生成数组；再在每个数组中找到最大的K个子数组和；在两个数组的最大K子数组和中找到乘积中的第K大
考虑到矩阵元素可能为负数，除了求出最大的K个子数组和，还需要求出最小的K个子数组和，其乘积也有可能是前K大的子矩阵和

2.在长度为N的数组中求前K大的子数组和
2.1.第K大
所谓第K大的元素，是指数组中大于该元素的元素至多有(K-1)个。
设第K大元素为X，则 CountGreater(X)>K-1 , 即CountGreater(X)>=K，其中CountGreater(x)表示集合中比x大的元素个数
而CountGreater(x)对于x是单调不增的，所以可以用二分法求出第K大元素X

2.2.求子数组和比X大的子数组个数
设数组前缀和为P[i]，则子数组和为：{P[0],P[1],...,P[N-1],P[1]-P[0],P[2]-P[0],...,P[N-1]-P[N-2]}
即需要求出两种情况的个数：
a: P[i]>X
b: P[j]-P[i]>X, j>i
情况a易得，情况b中，可以固定子数组的一端求另一端的个数：
b: P[j]>P[i]+X, j>i
则可以从大到小遍历i,对于每个P[i]，累加P[j]>P[i]+X, j>i的个数。注意这里随着i变小，需要检查的j的个数是增加的。
题解中建议使用splay tree等平衡树，这里使用bit+数值压缩完成，实现上简单一些：
前缀和P[i]只有N个，而需要动态求出大于某个值(P[i]+X)的个数，可见具体数值是不重要的，相对关系是重要的。
所以前缀和P[i]可以映射为1~N的数组，用map记录映射关系。通过map.upper_bound直接找到大于P[i]的树状数组坐标
通过树状数组来动态更新某个值的出现次数，
正好可通过map.upper_bound直接找到大于P[i]+X的树状数组坐标，
并利用树状数组的rangeSum进行区间查询求得(P[i]+X,INFINITE)的个数。
映射时留出0给bit的0位，为了不特殊处理最大的P[i]，还可以再多加一个INFINITE值。
共计需要O(NlogN+N)的时间

2.3.求第K大的子数组和
比X大的子数组和的个数相对于X是单调不增的，因此可以二分法+2.2.求出第K大的子数组和X
时间复杂度为：

2.4.求前K大的子数组和
类似于2.2. ，用map记录每个子数组和出现的个数。从大到小遍历P[i]，将大于P[i]+X的子数组和记录下来
如果数量不足K个，说明第K大的元素X不止一个，全部补充为X即可。
用同样的方法可以找到前K小的子数组和：只要对每个前缀和P[i]取相反数，求得前K大的子数组和后再取反。
时间复杂度为：O(NlogN+K)

2.5.求比X大的矩阵和个数
可以转换为求两个数组乘积中比X大的元素个数。
对于一个数组的每个元素，如果另一个数组是排序的，则可以通过二分法求得符合条件的乘积个数。
所以需要O(KlogK)的时间

2.6.求第K大的矩阵和
由于比X大的矩阵和个数相对于X单调不增，所以可以通过二分法求得第K大的矩阵和
时间复杂度为：O(log(range))

2.7.最大和最小子数组和的数组可能有重叠
有重叠时可能有矩阵和在最大子数组和及最小子数组和中重复计算，因此需要排除这种情况
注意到最大和最小子数组和的数组总长度不超过2*K，可以求出所有子数组和用2.5.+2.6.求得结果

总时间复杂度：

Problem C. 
