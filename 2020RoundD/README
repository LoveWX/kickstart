Problem A. Record Breaker

Problem B. Alien Piano


Problem C. Beauty of tree


Problem D. Locked Doors
一排N个房间一字排开，两个房间之间有一把锁，锁有一个难度等级
参观时从任意房间开始，参观当前房间后，打开两把锁中难度较低的一把进入下一个房间
给出Q个请求，求从房间S开始第K个参观的房间是哪一个？
对于某个锁而言，可以找到其左侧右侧比它难度高的锁
如果这个锁先开，那么在左侧右侧比它难度高的锁打开之前，两者之间的所有锁都会打开
因此可以构建一棵锁的树，某结点的父结点对应其左侧右侧比其难度高的锁的小者，即这两个锁的难度小者
而树结点本身又需要保持初始的顺序。因此可以用笛卡尔树来表示：
如果一个结点只有一个子结点：
1.起始结点在其子树内：则会先访问子树的所有结点，再访问该结点
2.起始结点在其子树外：则会先访问该结点，再访问子树的结点
如果一个结点有两个子结点：
则会先访问起始结点所在的子树，访问完子树中的所有结点后，访问该结点，再访问另一子树的结点
对于一个请求，起始房间是S，起始结点(锁)是X，求第K个访问的房间。设size(A)表示结点A及其子树中的结点数
如果size(X)>=K，表示结果在结点X的子树中。而X实际上是S左侧或右侧的锁，因此朝着X的方向找第K个房间即可
如果size(X)<K，表示结果不在结点X的子树中。需要在笛卡尔树中使用倍增法向上找到结点Y使得size(Y)>=K
这样，在访问完结点Y的包含结点X的子树之后，访问结点Y，再访问结点Y，再朝着另一子树的方向依次访问直到第K个房间
用单调栈建立笛卡尔树需要O(N)的时间，dfs计算父结点、子树结点数等信息需要O(N)的时间
计算倍增法需要的辅助矩阵需要O(NlogN)的时间
对于每次查询，使用倍增法找到特定结点需要O(logN)的时间，其它在O(1)时间完成
因此总时间复杂度为O(NlogN+QlogN)
