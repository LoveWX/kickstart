Problem A. Record Breaker
给定数组，如果一个元素满足以下两个条件，就是“创纪录的”：
1.该元素比前面的任何一个元素都要大
2.要么该元素是最后一个元素，要么该元素比其后的一个元素要大
求“创纪录的”元素的个数。
维护一个前缀最大值，遍历一次即可

Problem B. Alien Piano
将一个由K个音节组成的歌转成只有4种音节的歌，对于每个音节要求：
1.如果原歌中一个音节比前一个音节高，则新歌中该音节比前一个音节高
2.如果原歌中一个音节比前一个音节低，则新歌中该音节比前一个音节低
3.如果原歌中一个音节和前一个音节一样高，则新歌中该音节比前一个音节一样高
求新歌违反这些规则的最小次数
对每一位记录如果采用4种音节中的一种，从头开始的新歌违反规则的最小次数。依次dp即可

Problem C. Beauty of tree
给定N个结点的树，A随机选择一个结点，并从该结点开始到根结点的路径上每隔a个结点标记一次；
B随机选择一个结点，并从该结点开始到根结点的路径上每隔b个结点标记一次。求该树上被标记结点数的数学期望
两人取点是独立事件，在所有的N*N种情况中，A标记的结点数加上B标记的结点数减去AB共同标记的结点数，即为所有被标记的结点数
即：Count(A)+Count(B)-Count(A & B)
通过dfs记录层数，可以计算每个结点的kth祖先结点。如果选中某个结点，则该结点及其kth祖先结点，kth祖先结点的kth祖先结点等等都会被标记
以此可以递归求出每个结点都被选中1次，共N次选择中，每个结点被标记的次数。这样Count(A)和Count(B)均已求出
注意这里Count(A,P)表示在A的N次选择中结点P被标记的次数，叶结点的数值较小而根结点的数值较大。
在所有的N×N种情况中，对于A选择了结点P的情况（B的选择未定，共N种情况），相当于“选择”了P的ath祖先结点和“标记”了结点P，
前者相当于问题规模更小的子问题（离根更近）：选择了结点P，也会导致P的一些祖先结点被AB同时标记，而非P结点的情况实际上就是结点P的ath祖先结点的结果
后者相当于只是“标记”了结点P，而没有标记其祖先结点，这相当于N中情况中结点P被B标记的次数
因此，Count(A & B)也是可以求的。
求上述所有子结果都需要遍历所有结点一次，所以时间复杂度为O(N)

Problem D. Locked Doors
一排N个房间一字排开，两个房间之间有一把锁，锁有一个难度等级
参观时从任意房间开始，参观当前房间后，打开两把锁中难度较低的一把进入下一个房间
给出Q个请求，求从房间S开始第K个参观的房间是哪一个？
对于某个锁而言，可以找到其左侧右侧比它难度高的锁
如果这个锁先开，那么在左侧右侧比它难度高的锁打开之前，两者之间的所有锁都会打开
因此可以构建一棵锁的树，某结点的父结点对应其左侧右侧比其难度高的锁的小者，即这两个锁的难度小者
而树结点本身又需要保持初始的顺序。因此可以用笛卡尔树来表示：
如果一个结点只有一个子结点：
1.起始结点在其子树内：则会先访问子树的所有结点，再访问该结点
2.起始结点在其子树外：则会先访问该结点，再访问子树的结点
如果一个结点有两个子结点：
则会先访问起始结点所在的子树，访问完子树中的所有结点后，访问该结点，再访问另一子树的结点
对于一个请求，起始房间是S，起始结点(锁)是X，求第K个访问的房间。设size(A)表示结点A及其子树中的结点数
如果size(X)>=K，表示结果在结点X的子树中。而X实际上是S左侧或右侧的锁，因此朝着X的方向找第K个房间即可
如果size(X)<K，表示结果不在结点X的子树中。需要在笛卡尔树中使用倍增法向上找到结点Y使得size(Y)>=K
这样，在访问完结点Y的包含结点X的子树之后，访问结点Y，再访问结点Y，再朝着另一子树的方向依次访问直到第K个房间
用单调栈建立笛卡尔树需要O(N)的时间，dfs计算父结点、子树结点数等信息需要O(N)的时间
计算倍增法需要的辅助矩阵需要O(NlogN)的时间
对于每次查询，使用倍增法找到特定结点需要O(logN)的时间，其它在O(1)时间完成
因此总时间复杂度为O(NlogN+QlogN)
