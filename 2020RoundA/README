Problem A. K-Goodness String
给定字符串S，其得分为轴对称后不一样的位个数，即S[i]!=S[N-i+1]的个数，其中1<=i<=N/2
每次操作可以修改一个字符，求将S的得分修改为K的最小操作数
每次操作可以使得分加1或者减1，因此计算字符串S的得分A，abs(A-K)即所求

Problem B. L Shaped Plots
给定一个格点，只包含0和1。定义1-线段为橫行或纵行一串连续的1。
定义L形为符合以下条件的两个1-线段：
1.由两个1-线段组成，它们互相垂直，共享一个端点，该端点即垂足
2.长线段和短线段至少长2，长线段的长度是短线段的2倍
在给定的格点上计算所有的L形的个数
将每个1点作为L形的端点，计算朝上下左右四个方向最多能延伸出多少个1
再对于每个1点，分别使用垂直的两边组成L形，计算能组成多少个

Problem C. Rabbit House
在R*C的矩阵上初始有一些由1*1*1正方体组成的柱子，如果没有相邻的格点高度差大于1，矩阵就是安全的
求最少需要添加多少个格点能够使矩阵变为安全的
只能将较低的柱子加高，因此需要从高到低遍历每个柱子
如果柱子高度低于期望高度，就加高到期望高度。柱子的实际高度为max(柱子原高度,柱子期望高度)
该点柱子四周的点期望高度即为该点的实际高度减1

Problem D. Checksum
有一个R*C的布尔矩阵，给定每行每列的异或和。布尔矩阵中有一些值被改变为-1，需要修复。
每个格点修复都有对应的代价。求修复整个布尔矩阵的最小代价。
重建一个新图，原图的每一行每一列对应于新图的一个结点，
而每个需要修复的点为新图的边，端点为其所在的行和列对应的结点，权值为修复的代价
新图中孤立的结点表示该点对应的某行或某列没有待修复点
如果新图中某个点只连接了一条边，则说明该点对应的某行或某列只有一个待修复点（就是那条边），可以零代价直接推算出值
而如果新图中有环，就需要选择环上最小代价的边来破环，环上其它的边就能依次零代价推算出来
可见只需要在新图上求“最大生成树”，未加入“最大生成树”的边即为要修复的边
原图中有N^2个点，意味着新图中最多有N^2条边，由Kruskal方法时间复杂度为O(N^2*logN)
