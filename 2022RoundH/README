Problem A. Running in Circles
环形跑道长度为L，在起点有一个计数器。计数器可以记录方向，人离开起点时自动更新为离开的方向。
如果经过或者到达起点且与计数器方向相同，则计数器圈数加1；如果方向不同则更新计数器方向为跑动方向。
给出许多段跑动的距离和方向，求最终的圈数。
模拟即可，但是要注意离开起点和到达起点时也要更新方向。

Problem B. Magical Well Of Lilies
魔法水井中有L朵百合花，有三种操作：
1.投1枚硬币，水井给1朵花；
2.投4枚硬币，水井记录下已经给出的花的总数，开始时该记录为0
3.投2枚硬币，水井给出上次记录的数量的花
如果水井中的花少于某次操作应给的数量，则水井一朵花也不会给
给定花的数量L，求最少需要多少硬币才能获得全部的花。
将三种操作按照其硬币数命名为op1 op4 op2。需要恰好获得L数量的花。
对于op2而言，一定是在op4之后，而且某次op4之后的op2获得的数量一致。
因此可以将操作序列按照op4划分开，每个操作段都由1个op4开头(除了第一段)，后续一些op2和op1
这样就可以看出明显的dp结构，即每个操作段都是基于之前操作段的结果，即基于之前的结果。
因此本操作段可以视为已经得到k朵花之后再进行本操作段的操作得到下一个结果。
因此只考虑最后一个操作段即可。
对于一个操作段来说，其中op2获得的数量一致，op1获得的数量固定为1，
因此该操作段中除了开头的op4之外，其余的op2和op1可以任意交换位置
那么将本操作段调整为op4后紧接op2，再紧接op1的形式。
如果操作段的最后一个操作为op1，那么整个操作可以视为先到达了L-1，再通过op1到达L；
如果最后一个操作为op2，那么最后一个操作段中没有op1，
因此最后一个操作段之前获得的数量k一定能够整除L。
此时可以遍历L所有的约数，得到最优解。需要时间为O(sqrt(L))。
因此总时间复杂度为O(L*sqrt(L))。
如果不是对于每个l值都遍历可能的约数，
而是在计算得到某个l的解后更新其倍数的解，即更新所有xl<=L的解，
总计算次数即为1+1/2+1/3+...+1/L，这是调和级数，需要O(logL)
总时间复杂度为O(L*logL)。
注意这里解决最后一个操作段上的子问题时，拆分的角度比较难想到，
并没有纠结于计算操作段中op2和op1的数量，
而是将没有op1时的子问题用“恰好x次获得指定数量L，因此每次获得数k=L/x”来解决；
将有op1时的子问题用“最后一次操作是op1”的方式解决（实际上是递归op1数量不为0的所有情况）

Problem C. Electricity
城市电网有一些结点组成树，每个结点有容量值Ai。
当一个结点i通电时，与其直接相连的且容量小于Ai的结点也会通电。
选择一个结点通电，使得电网中通电的结点数最大，求该最大值。
对于一条边相邻的两个结点，由于容量已知，那么可能的通电方向也已知，当然也可能双向不通电。
由此构建出原树的子图，为原树多个子树构成的森林。求每个子树的结点数的最大值即可。

Problem D. Level Design
对于一个1~N的排列C，如果满足：
C[ai]=ai+1, 1<=i<=k-1  并且  C[ak]=a1
则称这k个元素组成了一个k环。
给定一个1~N的排列C，每次操作可以交换C中的任意两个下标的元素
求出分别组成1环,2环,...,N环需要进行几次操作。
1.先对原问题转化一下
1.1.C中必定有一些元素已经组成了一些k环。可以先将这些k环计算出来
1.2.对于一个k环包含2个以上元素，对于其中的两个下标ai和aj，交换C[ai]和C[aj]
就可以得到分别包含ai和aj的两个环，设ai到aj的长度为m，
则包含aj的环长度为m，包含ai的环长度为n-m
这说明，对于已经存在的k环，可以通过一次操作得到任意m环,1<=m<k
1.3.对于一个x环ai，和一个y环，从两环中分别任务各选择一个元素ai和aj
可以通过交换C[ai]和C[aj]将两个环连接起来，得到一个(x+y)环
这说明，已经存在x环和y环，可以通过一次操作得到(x+y)环
这样，就可以将原问题等价于另一个问题：
给定数组B，其中只包含正整数元素，元素和为N。一次操作可以将两个数合并为它们的和
也可以将一个数拆分为和为该数的两个数。求分别获得1~N的每个数需要的最少操作数
2.从拆分角度考虑，在获得某个数的最优操作集中，最多只会有一个拆分操作。
因此从大到小排序数组B，对于B[1]+B[2]+...+B[i]，需要i次操作，而对于数值X
B[1]+B[2]+...+B[i-1]<X<B[1]+B[2]+...+B[i]，则需要i-1次操作。
从合并角度考虑，可以将问题看作一个背包问题，状态转移公式为：
dp(i,j)=min(dp(i-1,j),1+dp(i-1,j-B[i]))
表示使用了B[1...i]的元素时组成数值j的最小操作数是多少
这两种角度获得特定数值的较小值即为解。时间复杂度为O(N^2)，可以通过小数据集
3.从上述包含拆分过程来看，每一种数值的操作数是有上限的。即：
对于X=B[1]+B[2]+...+B[i]，操作数为i
对于B[1]+B[2]+...+B[i-1]<X<B[1]+B[2]+...+B[i]，如果能够找到其它i个数使得和为X，
则其操作数也为i，否则为i+1
这样只需要通过类似背包的过程判断某个数值是否可以通过加和得到，即可通过上述过程求得解
例如B=[4,3,2]，每次新加入一个元素后能够得到的数值为：
     0 1 2 3 4 5 6 7 8 9
     1
B[1] 1       1
B[2] 1     1 1     1
B[3] 1   1 1 1 1 1 1   1
相比于背包算法，dp中的状态数可以压缩，因为不需要计算具体数值，只需要知道某个值是否可以达到
那么可以用位运算来压缩计算量。对于每个数值，相当于对上一个bitset左移再或上一个bitset得到本次结果
但是要注意的是，每次左移的长度可能变小，需要用掩码屏蔽一些bit位。
例如上述计算B[2]的过程，计算B[1]时的bit[1]是不能左移或的，因为数值4已经得到最小值了
只有bit[2]更新了bit[5]，bit[3]更新了bit[6]，bit[4]更新了bit[7]
因此每次计算一个新的元素时，需要更新掩码，缩小每一段进入下一段的长度
这样就可以计算出“上限”结果，时间复杂度为O(M*M/64)，M为数组B的长度
这样需要大约1.5*10^8次计算，仍然有可能超时。
注意到对于B[i]==1来说，在上述过程中最多只需要执行一次，剩下的B[i]==1只可能将最高bit位右移
因此单独处理剩余的B[i]==1即可。
这样B中元素全部是2时是最差情况，此时时间复杂度为O(N/2/64 * N/2 + N)，约为3.9*10^7，可以过大数据集
4.另一种方法是，用双端队列加速背包。关键在于从状态转移的过程中转换为求滑动窗口最小值。
从状态转移方程
dp(i,j)=min(dp(i-1,j),1+dp(i-1,j-x)),其中x为本次处理的元素的值，x=B[i]
可知，状态j和状态j-x相关，但是这只是本次状态转移时只添加一个新元素造成的。
可以将数组B中的元素按值分类计算个数，在状态转移时一次性考虑该值的所有状态，即
dp(i-1,j),dp(i−1,j−x),dp(i−1,j−2*x),…,dp(i−1,j−cnt(x)*x),其中cnt(x)为元素x的个数
对于每个j而言，只需要考虑这cnt(x)+1个状态即可，相当于是j左侧的一个窗口，求出窗口中的最小值即可
那么对于每一种x分开处理。对于每个x，将1~N按照模x的余数，分别用滑动窗口最小值来处理。
这样每个x总计需要处理N次。而最差的情况下，x值共有sqrt(N)种。
因此这种方法的时间复杂度为O(N*sqrt(N))
