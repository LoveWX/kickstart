Enumerating all submasks of a given mask
在状态压缩动态规划中，会将状态压缩为一个掩码，而当需要从此状态进行状态转移时，经常需要遍历该掩码的所有子掩码。
如13(1101)，其子掩码为 1101, 1100, 1001, 1000, 0101, 0100, 0001, 0000

使用如下的for循环可以遍历
for (int s=m; s; s=(s-1)&m)
    //... you can use s ...

注意在这种循环中，子掩码0是没有遍历的，可以在循环外遍历，或者将循环判断条件修改为
for (int s=m; ; s=(s-1)&m)
{
    //... you can use s ...
    if (s==0)  break;
}
这种写法如果缺少对子掩码0的判断可能造成无穷循环

如果只看原掩码指定的k位，相当于从2^k-1 ~ 0的遍历。
关键在于s=(s-1)&m的操作中会将最低位的1取消，并将低于该位的所有位(此时为0)置1
正好可以和原掩码做与操作将不相关的位置0
这也是从大到小遍历而不是从小到大遍历的原因

当用n个bit位表示所有状态时，从0遍历到(1<<n)-1，可以使用这样的循环
for (int m=0; m<(1<<n); ++m)
    for (int s=m; s; s=(s-1)&m)
        //... s and m ...
内层循环的循环次数为O(3^n)

证明1：对于每个bit，有三种情况：
1.该bit不包括在m中，也不包括在s中
2.该bit在m中，但是不包括在s中
3.该bit同时包括在m和s中
所以总共有3^n种组合

证明2:
设m中有k个bit为1，则此时共有2^k个子掩码，而k个bit为1的掩码一共有C(n,k)种，所以总共有：
C(n,0)*2^0+C(n,1)*2^1+...+C(n,n)*2^0
由二项式定理即可得上式值为(1+2)^n，即3^n
