Z-algorithm
求Z函数的线性方法
对于个长度为 n 的字符串 s。定义函数 z[i] 表示 s 和 s[i,n-1]（即以 s[i] 开头的后缀）的最长公共前缀（LCP）的长度。

对于长度为n的字符串s，定义函数z[i]表示s和s[i,n-1]（即从s[i]开始的后缀）的最长公共前缀(LCP)的长度。
特殊地，s==s[0,n-1]，因此z[0]=n，一般没有意义，并不求取
从i=1到i=n-1依次计算z函数的值，在此过程中，我们会利用到已经计算到的z函数的值。
对于i而言，称区间[i,i+z[i]-1]是i的匹配段，也叫Z-box。注意z函数的定义，匹配段表示了从s[i]开始的能够、匹配s前缀的最长子串。
在计算过程中，需要维护当前右端点最靠右的匹配段，记该匹配段为s[l,r]。
根据定义，s[l,r]和s的某个前缀相等，即s[l,r]==s[0,r-l]
因此对于i,l<=i<=r，则有s[i,r]==s[i-l,r-l]

对于每一个i而言：
如果i>r，说明当前没有右端点在i右侧的匹配段可以复用。因此需要从i开始暴力匹配s[0..]和s[i..]来求出z[i]。并将[i,i+z[i]-1]作为新的最右匹配段
如果i<=r，那么根据[l,r]的定义有s[i,r]=s[i-l,r-l]，因此z[i]>=min(z[i-l],r-i+1)。这时：
若z[i-1]<r-i+1，则z[i]=z[i-l]
若z[i-1]>=r-i+1，又因为s[i,r]=s[i-l,r-l],说明z[i]至少为r-i+1，但是仍然可能匹配更长的前缀。
因此从z[i]=r-i+1开始，暴力匹配下一个字符扩展z[i]直到不能扩展为止。此时最右匹配段也需要向右扩展，变为[i,i+z[i]-1]

因此只有i<=r且z[i-l]<r-i+1时不需要扩展匹配，其它情况需要扩展最右匹配段
注意当i>r时，r-i+1可能小于0，此时z[i]=0

对于每次向右扩展操作而言，r的值至少增加1，因此Z算法的时间复杂度为O(n)

vector<int> CalcZ(string &s)
{
    int n=s.size();
    vector<int> z(n,0);
    for(int i=1,l=0,r=0;i<n;++i)
    {
        if(i<=r && z[i-l]<r-i+1)
        {
            z[i]=z[i-l];
        }
        else
        {
            z[i]=max(0,r-i+1);
            l=i;
            while(i+z[i]<n && s[z[i]]==s[i+z[i]])
            {
                z[i]+=1;
            }
            r=i+z[i]-1;
        }
    }
    return z;
}

Z算法的用法
1.匹配所有模式串
可以在文本T中查找模式串P的所有出现。
先构造新的字符串S=P+'$'+T，其中'$'为P和T中都没有出现的字符。
然后求出S对应的Z函数，然后从S中T开始的位置开始，即下标i=|P|+1开始，检查每个Z[i]的值，
当Z[i]==|P|时，说明T[i-|P|-1]匹配|P|长度的模式串P的前缀，即匹配整个模式串P，因此为P的一个出现位置
时间复杂度为O(|P|+|T|)

2.查找字符串的周期
给定一个长度为n的字符串s，找到其最短的整周期，即寻找一个最短的字符串t，使得s可以被若干个t拼接而成的字符串表示。
计算s的Z函数，则其整周期的长度为最小的i，满足 n%i==0 且 i+z[i]=n
