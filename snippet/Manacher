Manacher算法用于求给定字符串S的所有回文子串。时间复杂度为O(n)。
相比于其它算法，Manacher算法压倒性的简单，并具有较小的常数项。
Manacher算法将问题转换为：对于字符串S中的每一位，如果以其为回文中心，最长的子回文串半径有多长。
子串可能有奇数长度和偶数长度两种。对于字符串S中的某一位S[i]，
以其为回文中心的奇数长度的子回文串为S[i-k],...,S[i],...S[i+k]，半径r=k+1，总长度为2r-1
以其为回文中心的偶数长度的子回文串为S[i-k],...,S[i-1],S[i],...,S[i+k-1]，半径r=k，总长度为2r
其半径也表示了以某个字符为中心的回文子串的个数
对于奇数长度子回文串，用数组d1[]表示，即d1[i]表示以S[i]为回文中心，最长子回文串的半径；偶数长度子回文串用数组d2[]表示

这里先计算奇数长度的回文子串，即d1[]
朴素算法是，对于每个位置S[i]，都朝两侧尽量扩展回文子串的长度，就可以求解。
可改进点是，右侧的点没有用到左侧的信息，导致了重复计算。
Manacher算法：
维护已找到的最靠右的子回文串[l,r]（即“外部”回文串）的边界（即具有最大r值的回文串）。
初始时，我们置l=0和r=-1（-1需区别于倒序索引位置，这里可为任意负数，仅为了循环初始时方便）。
现在需要计算d1[i]，之前的d1[0],...,d1[i-1]已经计算得到。
1.如果当前字符位于“外部”回文串之外，即i>r时，需要调用朴素算法，逐个扩展当前“内部”回文串。
即检查S[i-d1[i],...,i+d1[i]]是否为回文串。直到遇到第一个对应字符不同，或者遇到原串边界。
这样就求得d1[i]，并需要更新“外部”回文串。
2.当前字符位于“外部”回文串内，即i<=r时，可以从已经计算过的d1[]值中获取一些信息。
设在“外部”回文串中i的对应位置为j，即j=l+(r-i)。
因为位置j和位置i对称，几乎可以置d1[i]=d1[j]，因为它们都在“外部”回文串内部。
例外的情况是，“内部”回文串到达“外部”回文串的边界时，即j-d1[j]+1<=l，亦即i+d1[i]-1>=r
这时应该截断“内部”回文串，即置d1[i]=r-i，再调用朴素算法逐个扩展d1[i]
这样就求得d1[i]，并需要更新“外部”回文串。回文串[l,r]的中心下标为(l+r)/2.
vector<int> ManacherOdd(string &s)
{
    int n=s.size();
    vector<int> d1(n);
    for(int i=0,l=0,r=-1;i<n;++i)
    {
        int k=(i>r ? 1 : min(d1[l+r-i],r-i+1));
        while(0<=i-k && i+k<n && s[i-k]==s[i+k])
        {
            ++k;
        }
        d1[i]=k;
        if(i+k-1>r)
        {
            l=i-k+1;
            r=i+k-1;
        }
    }
    return d1;
}

对于偶数长度的回文子串，即d2[]，需要稍加调整。回文串[l,r]的中心下标为(l+r+1)/2.
vector<int> ManacherEven(string &s)
{
    int n=s.size();
    vector<int> d2(n);
    for(int i=0,l=0,r=-1;i<n;++i)
    {
        int k=(i>r ? 0 : min(d2[l+r-i+1],r-i+1));//i的对应位置为l+r-i，但是l+r-i是偶数串回文左中心，右中心是l+r-i+1
        while(0<=i-k-1 && i+k<n && s[i-k-1]==s[i+k])
        {
            ++k;
        }
        d2[i]=k;
        if(i+k-1>r)
        {
            l=i-k;
            r=i+k-1;
        }
    }
    return d2;
}

参考：https://oi-wiki.org/string/manacher/
