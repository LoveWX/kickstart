一棵树中包含n个节点，每个节点到根节点的路径包括了该节点的第i个祖先节点
可以通过倍增法(Binary Lifting)求得某个结点的第i个祖先节点，时间复杂度为O(logn)，空间复杂度为O(nlogn)
其本质是dp，dp[i][j]中存储的是第i个节点的第2^j个祖先节点的下标
这样，求第i个节点的第2^j个祖先节点，就可以转换成求第i个节点的第2^(j-1)个祖先节点的第2^(j-1)个祖先节点
即：dp[i][j] = dp[dp[i][j - 1]][j - 1]
这个转换的数学本质是对每个节点记录下2的幂次个的祖先节点，
这样对于第k个祖先节点，就可以依照k的二进制依次将节点上移：每次向根节点方向上移2的幂次个节点
而各个状态之间因为都是用2的幂次标识，互相之间转换也很方便
预处理时，dp[i][0]即为第i个节点的第2^0=1个祖先节点，即dp[i][0]=parent[i]
另外可以花费O(nlogn)的时间计算出每个状态的值，当然也可以用到的时候再计算
对于求第k个祖先节点的问题，还需要额外保存各个节点的高度，防止k的值越界。

// Binary Lifting to get Kth ancestor
vector<int> height;
vector<vector<int>> mem;
int dph(vector<int> &parent,int curr)
{
    if(height[curr]!=-1) return height[curr];
    return height[curr]=1+dph(parent,parent[curr]);
}

int dp(int curr,int pre2)
{
    if(mem[curr][pre2]!=-2) return mem[curr][pre2];
    return mem[curr][pre2]=dp(dp(curr,pre2-1),pre2-1);
}

void Init(int n, vector<int> &parent)
{
    height.assign(n,-1);
    height[0]=0;
    for(int i=1;i<n;++i)
    {
        height[i]=dph(parent,i);
    }
    mem.assign(n,vector<int>(16,-2));//2^16>=节点总数
    for(int i=0;i<n;++i)
    {
        mem[i][0]=parent[i];
    }
}

int Query(int node, int k)
{
    if(k>height[node]) return -1;
    for(int i=0;k!=0;++i,k>>=1)
    {
        if((k&1)!=0)
        {
            node=dp(node,i);
        }
    }
    return node;
}

//事先计算每个状态值的版本
int mem[SIZE][LOGSIZE];
memset(mem,-1,sizeof(int)*N*LOGSIZE);
for(int i=0;i<N;++i)
{
    mem[i][0]=parent[i];
}
for(int j=1;j<LOGSIZE;++j)
{
    for(int i=0;i<N;++i)
    {
        if(mem[i][j-1]!=-1)
        {
            mem[i][j]=mem[mem[i][j-1]][j-1];
        }
    }
}

//计算时从最高bit位开始依次尝试
for(int b=LOGSIZE-1;b>=0;--b)
{
    if(mem[Y][b]!=-1 && /*仍不满足条件*/)
    {
        Y=mem[Y][b];
    }
}
Y=parent[Y];
总体的思想是从起始点开始，从要上溯的k值的最高bit位开始，依次尝试向上查找
如果没有超过根结点，且仍然可以向上找（没有找到），就向上移动。
最终会找到结果结点的子结点，它的父结点即为所求。

倍增法(Binary Lifting)可以用于求结点的最小公共祖先：
先将深度较大的结点向上跳直到两个结点深度一致。如果两个结点重合，那该结点即所求
否则两个结点一起向上跳，直到两个结点的父结点一致，该父结点即为所求
int findLCA(int u,int v)
{
    if (depth[u] < depth[v]) swap(u,v);
    for (int b = MAXB-1;b >= 0;b--)
    {
        if (depth[mem[u][b]] >= depth[v])
        {
            u = mem[u][b];
        }
        if (u == v) return u;
        for (int b = MAXB-1;b >= 0;b--)
        {
            if (mem[u][b] != mem[v][b])
            {
                u = mem[u][b];
                v = mem[v][b];
            }
        }
    }
    return mem[u][0];
}
