Problem A. New Password
合法的密码需要至少7个字符，包含至少一个大写字母一个小写字母一个数字一个特殊字符
如果将给定字符串只通过添加字符的方式变为合法，至少需要添加多少字符
先判断有没有大写字母/小写字母/数字/特殊字符，如果某类没有就添加一个这类字符
如果字符串仍然少于7个字符，就补足到7个字符

Problem B. Range Partition
给一个[1,N]整数集合，从中选择一些数，使得这些数的和与剩下的数的和的比例为X:Y
设选择的数的和为A，剩下的数和为B，则：
A+B=S=(1+N)*N/2
A:B=X:Y
解得A=SX/(X+Y)
如果SX%(X+Y)!=0，则无解。否则可解出A的值。从N遍历到1，贪心地选择一些数使其和为A即可

Problem C. Ants on a Stick
有一个长L的棍子，上面有N个蚂蚁，每个蚂蚁朝棍子的一端爬行，速度均一样。
如果两个（朝向相反的）蚂蚁相遇，则它们立刻都回头继续爬行。
求蚂蚁从棍子两端掉落的编号序列。
可以用每个蚂蚁掉落前爬过的路程来标记掉落的顺序，路程越长掉落越晚。
那么问题转化为求每个蚂蚁掉落前爬过的路程。
考虑一开始时朝向不同方向的蚂蚁，
对于某个蚂蚁A而言，不妨设其向左爬，
那么在蚂蚁A左侧，只有朝右爬的蚂蚁才可能影响蚂蚁A，朝左爬的蚂蚁，蚂蚁A追不上。
而在蚂蚁A右侧，只有朝左爬的蚂蚁才可能影响蚂蚁A，朝右爬的蚂蚁，蚂蚁A追不上。
1.计算蚂蚁A从哪端掉落
1.1.如果蚂蚁朝向前方遇到另一个蚂蚁，那么该蚂蚁会回头；
如果回头遇到了第三只蚂蚁，那么该蚂蚁会再回头，朝向变回原方向。
1.2.因此判断蚂蚁最终从哪端掉落时，可以用其两端（可能影响它）的蚂蚁数量来计算
如果蚂蚁A左侧朝右爬的蚂蚁数量小于等于蚂蚁A右侧朝左爬的蚂蚁数量
那么蚂蚁A最终会从左端掉落。否则会从右端掉落。
2.计算蚂蚁A爬过的距离
2.1.如果两个蚂蚁同向爬行，它们之间的距离不会减少
如果两个蚂蚁相向爬行，到它们相遇时，它们各自爬行了它们初始距离的一半。
2.2.可以将蚂蚁爬过的路程按蚂蚁最后一次转向分成前后两段。
如果没有“最后一次转向”，即将开始时视为“最后一次转向”。
蚂蚁A最后一次转向之前，蚂蚁A要么向左爬，设路程为SL，要么向右爬，设路程为SR
设蚂蚁A向左爬遇到的最后一个蚂蚁为B
那么蚂蚁A向左爬时，都在和蚂蚁B以等速度相向而行，它们之间的距离以速度的2倍减少
蚂蚁A向右爬时，都在和蚂蚁B以等速度同向而行，它们之间的距离不变
那么，蚂蚁A向左爬行的距离即为SL=|PA-PB|/2
同理，设蚂蚁A向右爬遇到的最后一个蚂蚁为C，那么向右爬行距离为SR=|PC-PA|/2
所以，蚂蚁A最后一次转向之前爬过的距离即SL+SR
这样也就可以根据向左和向右的距离，计算出蚂蚁A最后一次转向时的位置
进而求出最后一次转向之后到掉落前爬过的距离。
注意最后一次转向之后只有一个蚂蚁在爬，之前是两个蚂蚁同时爬
注意如果初始方向的相向蚂蚁多，会导致蚂蚁最终在于初始方向相反的另一端掉落
因此初始方向上遇到的蚂蚁会比另一方向上多1个
3.蚂蚁初始朝右爬的情况同理

Problem D. Palindromic Deletions
给定一个字符串，每一步从字符串中等概率地选择一个下标
删掉该下标处的字符，得到长度减少1的新串
如果新串是回文串，则可以得到1分
直到字符串为空为止。求得分的数学期望。
设字符串长度为N，按照每次删除的下标区分，共有N!种情况。
则只要求出这些情况的得分的总和，即可计算出得分的数学期望。
想象一个树，第0层根结点对应原字符串，它有N个子结点，对应删除每个下标的情况
第i层结点都有N-i个子结点，对应删除剩下的N-i个下标的情况
那么每一种情况对应一条从根结点到叶结点的路径。
对于长度为K的某个子序列而言（只用下标区分不同字符），
从原字符串需要删除(N-K)个下标得到该子序列，共有(N-K)!种方式得到该子序列
即在树的第N-K层有(N-K)!个结点对应该子序列
而这个子序列还需要删除K个结点得到空串，共有K!种方式
即某个对应该子序列的结点的子树中有K!个叶结点
因此只要求得某种长度的所有子序列中有多少个是回文的即可。
设状态为dp(L,R,len)，表示在子串S[L,R]中长度为len的回文子序列的个数
基础状态为：
1.如果len==0，表示空序列，dp(L,R,len)=1
2.如果len<0，表示非法序列，dp(L,R,len)=0
3.如果L>R，表示非法序列，dp(L,R,len)=0
对于dp(L,R,len)，如果S[L]==S[R]，则有dp(L,R,len)=dp(L+1,R−1,len−2)
注意此时如果L==R，则dp(L,R,len)=dp(L+1,R−1,len−1)
注意此时S[L,R]即为单字符的字符串，
如果len==1，则dp(L,R,len)=1，否则dp(L,R,len)=0
这种情况可以覆盖前述的基础状态2了
如果S[L]!=S[R]，可以使用容斥原理来计算：考虑两个集合S[L,R-1]和S[L+1,R]
分别计算其中合法子序列的数量，将两个结果合并成S[L,R]上的结果时
S[L+1,R-1]上的结果被计算了两次，需要将其减掉。因此有：
dp(L,R,len)=dp(L,R−1,len)+dp(L+1,R,len)−dp(L+1,R−1,len)
状态共有O(N^3)个，每个状态需要O(1)时间计算，时间复杂度为O(N^3)
