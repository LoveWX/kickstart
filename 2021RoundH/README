Problem A. Transform the String
给定源字符串S和目标字符串F，每次操作可以将S中的任一字符变为其前或其后的字符，字母表是循环的
求最少的操作次数使得S中的字符都在字符串F中
先对每种字符计算两个方向拨动需要的操作次数，找到最小值
再依次计算S中每个字符需要的操作数，时间复杂度O(26+N)

Problem B. Painter
三种原色红黄蓝的刷子，可以将对未着色的格子着色，也可以对已着色的格子混色，混色规则为：
Red + Yellow = Orange
Red + Blue = Purple
Yellow + Blue = Green
Red + Yellow + Blue = Gray
给定一串格子及其期望的颜色，求最少连续刷格子的次数使得所有格子达到期望的颜色
每种颜色都可以看作红黄蓝中一种或几种颜色的混合，因此对三种颜色分别处理即可
对于每种颜色，将这串格子简化为“要刷”和“不要刷”两种，求出操作次数即可。即求出连续的段数。
时间复杂度O(N)

Problem C. Silly Substitutions
给定一个数字字符串S，依次循环进行以下操作：
 1.找到所有的子字符串01替换为2
 2.找到所有的子字符串12替换为3
 3.找到所有的子字符串23替换为4
  ...
 9.找到所有的子字符串89替换为0
10.找到所有的子字符串90替换为1
求最后剩下的字符串
操作是固定的，直接模拟即可
用map记录下每个下标的数字字符，用set记录下每种操作的子字符串，
依次循环尝试各种操作直到不再匹配任何字符串
找到一个字符串S[i]S[i+1]后，尝试删除它
需要先检查和前一个字符构成的子串S[i-1]S[i]是否也匹配一个操作串，匹配的话就需要删掉
同样也检查和后一个字符构成的子串S[i+1]S[i+2]
删掉子字符串S[i]S[i+1]，替换为(S[i]+2)%10
再检查新的S[i]是否和前一个字符S[i-1]构成新的操作符，构成的话就加入set中
同样也检查和后一个字符构成的子串S[i]S[i+2]
每次删除都可以减少字符串长度1，删除时需要查找set来检查前一个/后一个字符串，
因此时间复杂度为O(NlogN)
如果采用list代替map记录S中的各个字符，用unordered_set或者其它线性表替代set也可以
这样时间复杂度为O(N)

Problem D. Dependent Events
给定N个事件，这些事件构成一个树状结构，根结点是事件1，其它每个事件都有唯一的前置事件
对于事件1，给出它发生的概率；
对于其它事件，给出它在其前置事件发生时发生的条件概率，以及其前置事件不发生时发生的条件概率
求指定的两个事件同时发生的概率
设两个相互独立的事件为A和B，则它们同时发生的概率P(AB)=P(A)P(B)，注意前提条件是“相互独立”
因此本题需要注意不能直接套用该公式，主要需要使用条件概率来计算，即P(AB)=P(A)P(B|A)
对于事件树上的一对父子结点，设A为父结点，B为子结点，则题目给出的条件为P(B|A)和P(B|^A)
注意这里隐含给出了P(^B|A)=1-P(B|A)和P(^B|^A)=1-P(B|^A)
1.求每个事件单独发生的概率
可以直接用条件概率公式求得：
P(^A)=1-P(A)
P(B)=P(B|A)P(A)+P(B|^A)P(^A)
可以用dfs依次求取，时间复杂度为O(N)
2.求祖父结点和子结点的条件概率
设C为B的子结点，则有
P(C|A)=P(C|B)P(B|A)+P(C|^B)P(^B|A)
P(C|^A)=P(C|B)P(B|^A)+P(C|^B)P(^B|^A)
因此可以将祖父结点A和子结点C关联起来，而不用再通过父结点B来计算
以此类推，一个结点可以直接计算得到其任一祖先结点的条件概率
这样就可以计算任意两个事件同时发生的概率了
如果结点A是结点B的祖先结点，则它们同时发生的概率P(AB)=P(A)P(B|A)
如果结点A和结点B在事件树的一个分支上，设它们最近的祖先结点为D
则它们同时发生的概率P(AB)=P(AB|D)P(D)=P(A|D)P(B|D)P(D)，注意事件D发生时事件A事件B才是独立的
这样对于给出的任意两个事件，都是可以计算同时发生的概率的
但是由于事件的数量最多为2*10^5，不能事先计算每两个事件同时发生的概率，
因此需要用binary lifting的方法，对每个结点求出它和它祖先2的幂次步的结点的概率关系，需要O(NlogN)的时间
这样对每个查询，就可以将查询时间减少到O(logN)
因此总体时间复杂度为O(N+NlogN+QlogN)
