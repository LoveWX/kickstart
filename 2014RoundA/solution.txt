Problem A. Seven-segment Display
七段码表示一个数字，有一些LED是坏的，不亮。观察到一段从9~0~9的循环降序序列的LED显示方式，求下一个LED显示方式。如果有多种LED显示方式，则error。
如果至少观察了10个数字，则可以直接输出下一个LED显示。尝试观察序列是以0~9的某个数字开头，检测是不是全观察序列都符合条件。并同时求出下一个LED的显示。

Problem B. Super 2048
2048游戏，给定一个矩阵和移动方向，将所有非0元素按移动方向平移。如果一个元素和移动方向的前一个元素相同，则合并，新的元素为两者的和，但是新元素不再合并。求一次移动后的矩阵。
按指定的方向，按行或者列提取元素，模拟合并动作，补0，再拷贝回原数组。

Problem C. Addition
给定一些等式：a+b=v1。其中a,b是string，v1是数字。这些等式不会矛盾，但是可能不完备。另外给出一些算式：c+d，如果这些算式能够通过给出的等式集合推导求出确切值，就输出值，否则不输出。
由于有：
a+b=v1
b+c=v2
c+d=v3
对于变量a而言，a+b的值已知，a+d=(a+b)-(b+c)+(c+d)可求，而a+c的值无法求解。
将一个变量看做一个点，一个等式是连接两个点的边，边长为1。对于某一个变量/点而言，只有到该点距离为奇数的另一点，才能求出这两个点对应变量的和。如a+b和a+d。
注意当固定a点时，只要点b到点a存在一条长度为奇数的路径，就能求a+b。如果存在a+a=v1形式的等式，看做a->a的自环。
对于给定的算式，从一点出发bfs查找另一个点。注意这里需要路径长度为奇数，可以额外用一个变量表示目前处理的点距离起点长度是奇还是偶。
在每个点上保存到目前为止的结果，可以随起点和该点路径的奇偶性更新结果。
点a val=0，odd=0，
点b val=0+v1，odd=1
点c val=v1-v2，odd=0
点d val=v1-v2+v3，odd=1
注意对于每个点需要保存路径长度为奇或偶两种结果。只有当奇数路径中访问到终点时对应算式才可计算。
注意开始时，起点并未被访问过。

Problem D. Cut Tiles
给定N1,N2,... ，从M*M的一堆瓷砖上切下边长为2^N1,2^N2,...的正方形瓷砖，切缝平行于大瓷砖的边。求最少需要多少M*M的大瓷砖。
按小瓷砖边长从大到小切，因为小瓷砖的边长是2的幂次，所以当小瓷砖（正方形）放在一块能放下的大瓷砖（矩形）的左上角时，大瓷砖剩余的左下和右上两个部分无论如何放其它小瓷砖，都不会越过切缝的延长线。可以沿左上角小瓷砖切缝的延长线将大瓷砖的剩余部分切成三块，继续供其它需要切割出的小瓷砖使用。
用map存放两个边长表示每块瓷砖，边长第一维小于等于第二维，这样直接可以用lower_bound找到最合适的瓷砖。
