Problem A. Image Labeler
将N个数分配到M个类别中，每个类别非空，类别得分为类别中所有数的中位数。总分为所有类别的得分的和。
求可能的最大得分。
直觉上看，只有将一个数单独放到一个类别中，才能使得它的值最大。
因此从大到小将最大的M-1个数分别放到M-1个类别中，剩下的N-(M-1)个数放到一个类别中

Problem B. Maximum Gain
给定两个数列A和B，每次操作只能取出A或B的第一个或者最后一个元素。
限定K次操作，求能取得的数的和的最大值
求取出的元素的和的最大值，也就是求剩下的元素的和的最小值。
枚举数列A中和数列B中剩余元素的个数，分别求出剩余元素的和，求出最小值即可

Problem C. Touchbar Typing
给定一个有M个键的键盘，所有键排成一行，可能有重复的键。
现在需要输入长度为N的字符串S，初始时手指可以在任何位置。
在键盘上从一个键移动到另一个键的代价为这两个键的距离差。按下按键无代价。
求输入字符串S的最小代价。
如果键盘上没有重复的按键，那么只有一种按键方案，代价唯一。
有重复按键时，可以使用dp，记录下按完字符串S中的第i个字符Si，且手指在某个位置j时，需要的最小代价
这样只要从上一个字符转移到下一个字符，枚举按键位置，计算最小代价即可。
但是这样每次转移需要O(M*M)的时间，总计需要O(N*M*M)的时间。需要优化每次转移的时间复杂度。
在某一次转移中，对于某个目的按键而言，上一次按键可能在目的按键的左侧，也可能在右侧。
对于左侧的按键，到目的按键的距离是相对于下标线性的：下标越大，本次转移的代价越小
对于右侧的按键，到目的按键的距离是相对于下标线性的：下标越大，本次转移的代价越大
因此可以用两次遍历，依次求出每个目的按键从左侧转移来的最小代价和从右侧转移来的最小代价。
从左侧转移时，之前的代价和下标增长方向是不同的，可以使用 之前代价-出发按键下标 作为比较值
从右侧转移时，之前的代价和下标增长方向是相同的，可以使用 之前代价+出发按键下标 作为比较值
对每个目的按键求出最佳的出发按键后再具体更新代价。
这样需要时间复杂度为O(N*M)

Problem D. Suspects and Witnesses
有N个嫌疑人，其中最多有K个犯人。另有M份口供，都是“第i个人说第j个人不是犯人”的形式。
已知如果某人不是犯人，则其一定说真话；如果某人是犯人，则可能说真话也可能说假话
求在各种情况下，不可能是犯人的人有多少个
注意到口供的形式：“第i个人说第j个人不是犯人”，可以推出：
如果第j个人不是犯人，那么第i个人可能不是犯人，也可能是犯人
如果第j个人是犯人，那么第i个人一定是犯人
将每个人看作一个结点，如果是犯人记为1，不是犯人记为0
将一份口供看作一条从结点j到结点i的有向边，则问题可以形成一个有向图G
上述推理可以视作：如果父结点为1，则子结点为1
进一步地：1.如果某个结点为1，则其子树中所有结点为1
2.在有向图中如果出现强连通分量，那么强连通分量中的每个结点的值应该都一样
因此该强连通分量可以等价于一个结点
缩点之后可以形成一个有向无环图G'，而由条件“最多有K个犯人”可知，
需要在G'上尝试以每个结点为根形成子树，找到其子树结点个数大于K个的结点的个数
可以在使用tarjan方法缩点之后，用带记忆的dfs来求出每个结点的子树结点个数
但是这里注意到，K的值很小，K<=20
因此也可以不用缩点，在每个点dfs时，用一个set记录已知的子结点，并限制set的值最多为K+1即可
这种方法的时间复杂度为O(M+NKlogK)
