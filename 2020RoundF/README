Problem A. ATM Queue
N个客户在ATM前排队取款，每人要取款数为Ai，但是每人一次只能取款K，如果需要取更多的钱，只能重新到队尾排队
求完成取款的客户编号序列
每个客户按照取款数和单次取款上限可以计算出需要几次取款，根据取款次数和原队列中下标排列即可
时间复杂度O(NlogN)

Problem B. Metal Harvest
数轴上有一些线段需要进行采集。但是每次派出机器人采集时最多只能采集长度为K的连续一段。
求需要派出机器人的次数以采集所有的线段。
只需要贪心，从左侧开始，遇到带采集线段时，就派出机器人从左侧开始，采集最长长度K，并统计次数。
注意有可能派出一次机器人，可以采集多个线段，也可能会采集后续线段的左半段
待采集线段的长度也可能远大于每次采集长度，需要一次求取结果。
时间复杂度O(NlogN)

Problem C. Painters' Duel
在一个等边三角形的三边均匀切分S等分，并添加平行于边的线段将原等边三角形划分成小的等边三角形
每个小等边三角形代表一个单元格，和它共享边的其它小等边三角形与其相邻。
初始时一些单元格不能进入。给定A和B的初始位置，A和B轮流行动。
行动时如果当前玩家所在单元格有相邻的空单元格，则可以进入该单元格并标为自己的颜色。
如果没有相邻的空单元格，就不能行动。双方都无法行动时结束。
求双方都采用最佳策略时 A涂色单元格-B涂色单元格 的最大值。
首先将单元格编号，并将单元格及邻接关系用邻接表表示出来
注意到最多只有6层，即最多36个单元格。
考虑博弈中的状态。1.需要记录双方的位置，最多有36*36种可能
2.需要记录还有哪些单元格没有涂色。由于起始不能进入的单元格和被某一方涂色的单元格一样，
因此只需要记录单元格是否可以涂色即可，可以用一个long long 表示各个单元格状态
3.为了遍历方便，需要添加一个变量表示当一个玩家行动时，另一个玩家上一轮是否移动。
可以用map记录某个状态对应的最大差值
对于某个玩家的某一次行动而言，先判断是否还可以移动，再结合对手是否可以移动，
通过dp选择可能的最大差值作为当前状态的结果。

Problem D. Yeetzhee
给出N个M面的骰子，依次投每一个骰子，每个骰子可以投任意多次。
投完之后，将相同点数的骰子归为一组，记录下每组中骰子的个数，作为结果数组group
求要投出符合结果组的点数，需要投骰子的数学期望
目标数组中指定的是分组中各组骰子数量，而并不要求具体各组的点数
因此可以将分组个数(并排序)作为状态，来描述目前已经达到的状态
如骰子点数为[2,2,3,3,3,4,4]，则可以表示为[0,2,2,3]
这样就可以大幅减少状态总数
设每种状态达到目标状态的投数的数学期望为ei，当前状态到达该状态的概率为pi
设当前状态达到目标状态的投数的数学期望为x，则有：
x = 1 + (1 - Σpi)x + Σpiei
其含义为：每次投骰子都使投数加1，如果投到了其它合法（可以达到目标状态）的状态
则用概率pi和该状态的结果ei来累计到当前状态的结果中。
当然也可能投到了非法状态（无法达到目标状态），这时需要重投当前骰子，此种情况概率为(1 - Σpi)
此方程即作为每次dp函数的过程。其中x就是当前状态，ei就是dp中的另一个状态
需要比对当前状态和目标状态计算投出哪些点数是合法的，哪些点数是非法的，从而计算出当前状态的结果
具体到每次dp中，可以采用以下公式：
x=1+(M-V)/M*x+1/M*(E1+E2+...+EV)
其中Ei表示合法的，可以由当前状态转换到的其它状态，V表示这种状态的数量，也即当前骰子可以投出的合法点数
因此其它M-V种点数是不合法的，需要重投
以此可以用dp计算出结果
