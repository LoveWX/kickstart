Problem A. Coloring Game
共有1~N共N个白色格子，每人每次可以选择一个不与红色格子相邻的白色格子涂红并获得1分
机器人先开始，每次选择最左侧的合法的格子，人采用最优策略。
求机器人能获得的最大分数。
简单模拟，机器人选的是最左侧第一个合法格子，即和人选的格子中间间隔一个格子
人不考虑自己的得分，采取最优策略只需要尽量占据格子即可，需要和机器人选的格子间隔两个格子

Problem B. Students and Mentors
给出N个学生的能力值Ri，现在每个学生i需要找其他一个学生j作为导师，要求Ri<=Rj*2，
即导师的能力不能超过学生的两倍。多个学生可以找同一个导师。求每个学生的导师的最大能力值
可以将所有学生的能力值放到multiset中，找到符合条件的最大值
注意一个学生的导师不能是自己，需要先将自己从集合中取出，求得结果后再放回集合

Problem C. Matching Palindrome
给定一个回文字符串P，求一个最短的非空回文字符串Q，使得PQ是回文字符串
注意到P是一个回文串，如果Q==P，那么也符合要求，只是可能不是最短的，因此可以作为上界。
设P的长度和Q的长度一样的前缀为A，即P=AB，len(A)==len(Q)，则PQ=ABQ
由PQ为回文可知A==rev(Q)，而Q为回文，因此rev(Q)==Q，因此A==Q
这样一来，又因为ABQ为回文，因此B为回文。
因此只要找到最短的前缀A，使得A为回文且B为回文，即可得Q=A为所求
这里注意到由P,Q,PQ为回文推导出P可以分成两个回文串A,B且A==Q
类似地，可以从A,B,AB为回文推导出B可以分成两个回文串C,D且A==D
不断递推下去可知，P一定是某个字符串X的重复，即P=X^k，而所求Q即为X。
也就是说如果将P看作循环字符串，其循环节即为所求。
由于本题中循环节需要完整出现，因此由len(P)%len(A)==0的性质，遍历循环节的长度
找到最短的前缀A使得A,B为回文即可，时间负责度为O(N*sqrt(N))
另一种方案是，既然P是循环的，那么在PP中，一定可以找到一个子串G使得G=P。
当然要忽略第0个字符以保证找到循环节。因此实际上是在字符串P[1:]P[0:]中查找
而PP中子串G首次出现的位置即为第二个循环节开始的位置，因此就找到了循环节
使用KMP，可以在O(N)时间内查找到子串

Problem D. Pizza Delivery
在N*N的格点上，快递员需要从某点出发将P份披萨送给P个不同位置的客户，每个客户可能付一定量的小费
这些位置都在格点上，而每经过一个格点，需要根据(离开方向,现有金钱)从一个公式中计算出来离开后的金钱
求在M步中送出所有披萨后可能的最大金钱
虽然每个格点的金钱变化比较复杂，但是实际上由于较小的数据规模，可以采用DP来模拟状态进行推导
需要N*N的矩阵来表示走完每一步后恰好停留在某点的最大金钱，
不断从第i步的状态推导到第i+1步即可
注意：1.不能超出给定的格点
2.可以在某个格点停留
3.由于金钱可能是负值，格点的操作可能有乘法和除法，因此到达客户那里时也可以先不送出对应披萨拿到小费
因此需要区分每个披萨，需要2^P的状态
4.实际操作中需要使用long long来记录状态，使用INT_MIN表示无法达到的状态，
无法达到的状态转移之后仍是无法达到的状态
因此每步的状态数为N*N*2^P，需要走M-1步，时间复杂度为O(M*N*N*2^P)
