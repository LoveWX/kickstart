Problem A. Shuffled Anagrams
对于字符串S，如果字符串P包含S中的每个字符，但是在每一位上两个字符串均不相等，则称P为S的乱序字符串
给定字符串S，求一个乱序字符串
直觉上看，需要先对出现次数较多的字符安排不一样的字符。如果一个字符出现次数超过总数的一半，则不存在乱序字符串。
可以维护字符及其次数的对应表，每次取出出现次数最多的两种字符并将两种各一个配对，直到配对所有的字符
如果字符串长度为奇数，则最后一次配对是在3个不同字符之间进行的，特殊处理即可

Problem B. Birthday Cake
指定R*C的矩形格点的中间矩形一块，求需要切几刀能够将指定的块切成1×1的方块
每一刀要从矩形边或者之前某一刀切过的格点开始，不能经过被切过的格点，即使该点是某个切痕的端点
每一刀长度最大为K。
1.首先处理指定的矩形内部的线条，不包括矩形边上的部分，设矩形n行m列
1.1.考虑K足够长(K>=n,K>=m)，则总共需要切nm-1刀
直觉上来看，如果首先沿行切，则总共需要切n−1+n(m−1)=nm−1刀
而如果首先沿列切，则总共需要切m−1+m(n−1)=nm−1刀
更具一般性地，可以考虑先用长度为1的刀切分，然后再将其中的一些刀组合成一刀。
对于矩形内部的每个点来说，在用长度为1的刀切分时，每个点都连接不同的4刀。共有n(m−1)+m(n−1)刀
如果选择在该点将横向或者纵向的刀连接起来，则该点至多可以节省一刀。这样的点共有(n−1)(m−1)个
这样总共需要n(m−1)+m(n−1)-(n−1)(m−1)=nm-1刀
1.2.当K<min(n,m)时
由于刀长不够，则一定有一些点连接了不同的4刀，将这些点称为“红点”
由1.1的讨论可知，用长度为1的刀切分后，非红点可以节省一刀，而红点则不能节省
因此，需要让红点的个数尽可能地少
所以需要在横向和纵向上，偏向一侧依次紧密切出K*K的正方形，这样红点的个数最少
每行有floor((n-1)/K)个正方形，每列有floor((m-1)/K)个正方形，注意是在矩形内部切分，所以有'-1'
这样平均下来每个正方形恰有一个红点。例如靠左靠下排布正方形，则可以认为每个正方形的右上角为红点。
由1.1.的讨论可知，红点并不能节省一刀，因此一个红点需要多切一刀
总计需要nm-1+floor((n-1)/K)*floor((m-1)/K)刀
1.1.正是当K足够大时的特殊情况
1.3.当min(n,m)<=K<max(n,m)时
可以用长为K的刀切平行于短边的内部线条，这样就变成了1.1.的情况，需要nm-1刀
2.接着处理矩形外部和矩形边上的线条
由于需要从R*C矩形边界开始向内部切，因此从n*m矩形某边延长线和R*C矩形边界交点开始向内部切为最优
从起点切到n*m矩形，同方向继续切完整条边，再转弯90度，依次切n*m矩形的其它三条边
这样n*m矩形共4个顶点共8种情况，枚举找到最小刀数即可

Problem C. Palindromic Crossword
矩阵格点中有一些格点不能填字符。其它格点在每行每列连续的最长格点段上，所填字符都组成回文字符串。
现在已经有一个完成的矩阵格点，其中有一些格点被删除了字符。
求通过未删除格点字符能够推理出的字符个数，并打印推理后的矩阵格点
从每个已知的格点dfs推理对应的未知格点即可

Problem D. Increasing Sequence Card
N张牌上面分别印着1-N。随机洗牌之后，每次取一张，如果其上数字大于拿到手上的上一张牌的数字，则抓取这张牌，否则丢弃。
所有牌取完后，得分为手上抓取的牌的数量。求得分的数学期望。
如果取到的牌为i，则之后所有小于i的牌都会被丢弃，问题就变为了N-i规模，可以递推求解
E(n)=(1+f(n-1))/n+(1+f(n-2))/n+...+(1+f(0))/n
化简得：
nE(n)=n+E(n-1)+E(n-2)+...+E(0)
与相邻项相减可得：
nE(n)-(n-1)E(n-1)=1+E(n-1)
E(n)=1/n+E(n-1)
E(n)=1+1/2+1/3+...+1/n
这是调和级数，是发散的，但是仍有公式可以求近似值。
前10^7项暴力求解，后面的项用公式求解：
sigma(1/k)=lnk+r+ek
其中r为欧拉常数，r约为0.5772156649
ek约为1/(2k)
