Problem A. 

Problem B. Parcels
平面中一些格点是快递站，其它是空地。
每个空地到快递站的最小距离为该空地的分距离。这些分距离的最大值为全局距离。
求如果最多添加一个快递站，全局距离的最小是多少。
可以通过BFS求得每个空地到快递站的最小距离。
设全局距离最小值为k，则表示所有的分距离<=k。
对于k1>k，也满足分距离<=k1；而对于0<=k2<k，至少有一个分距离>k2。
因此可以使用二分查找来找到全局距离的最小值k，它是最小的使得各个分距离<=k的值。
借由曼哈顿距离转切比雪夫距离的方法:
|x|+|y|=max(|x+y|,|x-y|)
两点(x1,y1)(x2,y2)之间的距离可以表示为：
 dist((x1,y1),(x2,y2))
=|x1-x2|+|y1-y2|
=max(|x1-x2+y1-y2|,|x1-x2-y1+y2|)
=max(|(x1+y1)-(x2+y2)|,|(x1-y1)-(x2-y2)|)   (1)
对于每个可能的新增快递站位置(x2,y2)，(x2+y2)和(x2-y2)是定值
而当(1)式取到其最大值时，四种可能必居其一：
要么(x1+y1)取最大值；要么(x1+y1)取最小值；
要么(x1-y1)取最大值；要么(x1-y1)取最小值。
这样(1)式的两部分就可以拆开独立求解。相当于在切比雪夫平面上只考虑(x+y)轴或者(x-y)轴
因此需要对每个分距离大于k的空地(x1,y1)计算(x1+y1)和(x1-y1)。
所有空地的全局距离的最大值即：
max(|(x1+y1)max-(x2+y2)|,|(x1+y1)min-(x2+y2)|,|(x1-y1)max-(x2-y2)|,|(x1-y1)min-(x2-y2)|)   (2)
只要有空地(x2,y2)使得(2)式小于等于k，即表示全局距离为k是可行的。
因此对于每个固定的k，遍历每个格点，对于分距离大于k的空地，需要O(RC)的时间计算(2)式的值
所以需要O(RC)的时间检查是否存在空地使得所有分距离<=k
加上二分查找需要的O(log(RC))，总计需要O(RClog(RC))的时间

Problem C. Contention
剧场有[1,N]共N个座位，现有Q个预定，每个预定[L,R]执行时都能获得其预定范围[L,R]中所有未被分配的座位。
任意排列这Q个预定，使得每个预定实际获得的座位数的最小值最大，求这个最大值K。
即求最大值K，使得存在某种处理预定的顺序，使得每个预定至少能实际获得K个座位。
1)对于第i个预定，它能获得多少个预定，与已经处理的前i-1个预定的顺序没有关系
2)需要后处理能够获得较多座位的预定
2.1)对于两个相邻的预定，先处理分到座位较少的那个请求
设A,B是相邻的两个请求。假设若先处理A，则A得到a个座位；若先处理B，则B得到b个座位；设A,B两预定共得到c个座位。
由1)得c跟A,B被处理的先后顺序无关，且有a+b>=c。不妨设a>b。
若先A后B则两个请求得到的座位数的最小值为：min(a,c−a)=c−a, 因为a>b>=c-a
若先B后A则最小值为min(b,c−b)。因为
a+b>=c => b>=c-a
a>b => c-b>c-a
即有min(b,c-b)>=min(a,c-a)
换言之，对于相邻的两个请求，应当先处理(先申请时)分到座位较少的那个请求。
2.2)对于Q个中的最后一个预定，考虑在已经处理了其它Q-1个预定的情况下，选择能够获得最多座位数的预定。
对于若干个预定的所有排列，将每种排列中每个预定获得的座位数的最小值称为此"排列的最小值"。
2.2.1)从任意k(k>1)个预定的任意排列中拿走一个请求，余下的k−1个预定的排列的最小值一定不小于原先k个请求的排列的最小值。
这是由于去掉一个预定后，该预定后的其它预定有可能获得比原来更多的座位数。

2.2.2)定义f(x)表示最后一个处理预定x，x能得到多少个座位。将f(x)的最大值记作m。
对于Q个请求的任一排列P=p1,p2,…,pQ，设其最小值为a。
假设最后一个处理预定pQ不能获得最大值m，即f(pQ)<m，则有a<=f(pQ)<m。
设最后一个处理预定pi时取到最大值，即f(pi)=m；
考虑排列P′=p1,p2,…,pi−1,pi+1,pi+2,…,pQ ，设其最小值为b。
对比P和P′这两个排列，由2.2.1)得：
p1,p2…,pi−1这些请求获得的座位数不变；
而在P′中，由于少了pi的竞争，pi+1,pi+2,…,pQ这些请求获得的座位数不会减少；故有b>=a。
考虑排列P'':=p1,p2,…,pi−1,pi+1,…,pQ,pi，设其最小值为c，易见c=min(b,m)
又因为b>=a且m>a，故有c>=a 。所以把 argmax(f(x))放最后可取到最优解。

3)解法一,O(Q^2)
由2.2.2)，需要对Q个预定中的每一个，求得在其它预定已经完成的情况下，该预定能获得的座位数。
选择获得座位数最多的预定，作为第Q个预定。再处理剩下的Q-1个预定。
对每个座位记录它所有的预定，如果某个座位只有一个预定q，那么在预定q为最后处理的预定时，该座位是其可以获得的座位。
由此可以求出每个预定座位最后一个预定时，所能获得的座位数。
由于Q<N，可以通过扫描线从1到N扫描，依序遍历每个预定对应的起点和终点。这样只需要遍历2Q次。
所以算法概要如下：
从第Q次预定开始，依次决定第Q次,第Q-1次,...,第1次预定
从小到大遍历线段起点和终点，遇到起点时增加线段数，并在缓冲区记录该线段，遇到终点减小线段数。
当遇到某个点时(未处理该点信息)，线段数为1，说明该点和上一个点之间的一段属于某个预定，即最后执行该预定，该预定能获得这些座位
在缓冲区中通过线段终点信息（当前点<=线段终点）找到这唯一的线段，将座位累积到该线段上，重置缓冲区只保留这一个线段。
这样，每个线段只会进缓冲区1次，出1次，可以在O(Q)时间内找到获得座位数最多的预定作为最后一个。
总计时间复杂度为O(Q^2)。但是实际处理时很难在所有预定中剔除掉已找到的最后一个预定，采用标注预定是否已经处理的方案会超时。
可能需要如题解所述的线段树来处理。

4)解法二,O(Q^2*logQ)
所有排列的最小值的最大值为k，说明排列中的每个预定都至少能获得k个座位
可以用二分法查找k的最大值，使得每个预定都能获得k个座位
4.1)
如果两个线段不相交，那么谁先谁后无所谓
4.1.1)如果一个线段包含另一个，那么由2.2.1)，需要先执行被包含的线段
4.1.2)如果两个线段相交但是不互相包含，左侧的线段一定能获得的座位只有和右侧线段不相交的一段，
4.1.3)如果已经达到k个座位，那左侧线段可以后执行(不要右侧的座位)；
否则只能左侧线段先执行，这样右侧线段无法获得左右相交的部分座位，相当于右侧线段被迫将起点向右移动到左侧线段终点。
算法先对所有线段排序，按照起点从小到大，终点从大到小的顺序(使得每个线段可以找到它包含的其它线段)
然后执行Q次，每次检查最左侧的线段是否可以获得k个座位
注意由4.1.3)，后处理线段的起点可能会由于其左侧线段而向右"偏移"
4.2)对于最左侧线段，遍历其右侧线段两次，均以到达不相交的线段时终止
第一次遍历处理最左侧线段包含的其它线段，由于其它线段需要先执行，最左侧线段只能获得剩下的座位
如果剩下的座位不够，就以"不能获得k个座位"失败退出
从剩下的座位中从左到右分配k个座位，记录最后的位置为ed，这些座位必定只能由最左侧线段获得。
而ed右侧的其它剩下的座位，可以由右侧线段获得。这意味着，右侧某些线段可以在左侧线段之前执行。
第二次遍历处理与左侧线段相交但不互相包含的其它线段
如果这些线段起点在ed之后，那和最左侧线段不影响；
如果某个线段起点在ed之前，为了保证最左侧线段拿到k个座位，只好将这个线段放到最左侧线段之后执行了。
将该线段的起点"右移"到最左侧线段的终点后(而不是ed后)，即可达到这个目的。
如果不能先处理最左侧线段再处理该线段，会在处理到该线段时发现失败
时间复杂度为O(Q^2*logQ)，但是由于处理的最左侧线段不大可能包含右侧大多数线段，因此总体速度相当快。
