Problem A. Infinity Area
给定半径长度R和A,B
数列第一个值a[0]为R，新增加的值依次为上一个值乘以A(a[i]=a[i-1]*A)或者整数除以B(a[i]=a[i-1]/B)
直到数列值为0为止
求以数列的每个数为半径的圆的面积的和
依次计算每个圆的面积并累加即可

Problem B. Palindromic Factors
给定一个数N，求其所有因数中回文数的个数
依次尝试每个因数，累加回文数的个数即可
注意N=a*a时，a只能计算一次
时间复杂度O(sqrt(N))

Problem C. Unlock the Padlock
一个密码锁a有N个旋转表盘，每个表盘依次有D个值。
每次操作可以选择一段连续的表盘，将其值均加1或者均减1。每次操作选择的段需要包含上次操作的段。
求将所有表盘变为0需要的最少操作数
由于选择的表盘移动是相同的，因此它们之间的相对值差是固定的。
而最终需要值都变为0，因此已选择的表盘值一定是相同的，新增加某个表盘之前需要通过操作将选择的表盘调整为该表盘的值
可以限定每次新加表盘只能在已选择表盘的头部或者尾部新增一个。在同方向多次新增一个表盘可以表示为一次新增多个初始值相同的表盘
因此需要有两个坐标来表示已经选择的子串。
子串的值和最后一次新增有关，而最后一次新增只能是该子串的最左端或者最右端。该子串的值也和最左端或最右端的值相等
因此还需要一个值域来表示该子串最后一次新增的是最左端还是最右端
因此状态为dp[left][right][type]，当type==0时表示：
将a[left,...,right]值都调整为a[left]的操作次数
当type==1时表示：
将a[left,...,right]值都调整为a[right]的操作次数
CalcOper为计算将表盘从一个值调整为另一个值需要的操作数，转移方程为：
dp[le][ri][0]=min(dp[le+1][ri][0]+CalcOper(a[le+1],a[le]),dp[le+1][ri][1]+CalcOper(a[ri],a[le]))
dp[le][ri][1]=min(dp[le][ri-1][0]+CalcOper(a[le],a[ri]),dp[le][ri-1][1]+CalcOper(a[ri-1],a[ri]))
选择任一长度为1的表盘为初始状态：dp[i][i][0]==dp[i][i][1]=0
所求结果为dp[0][N-1][0]和dp[0][N-1][1]的较大者
状态共有N*N/2*2个，需要O(1)的时间依次求取每个状态，时间复杂度为O(N^2)

Problem D. Hamiltonian Tour
2R*2C的格点，每2*2的格点为一个block，要么都为空可以通过，要么都不空不可以通过
从(0,0)开始每次可以向四周走一格，求通过所有空格点并回到(0,0)且不重复访问格点的路径
如果只有2*2的格点，那么可以用
E S
N W
来顺序访问。如果有其它格点，可以认为是从已经访问的格点扩展而来的。
从已访问的格点按方向E扩展：
E S       ->    E E E S 
N W             N W W W 
按方向S扩展：
E S -> E S 
N W    N S 
       N S 
       N W 
按方向W扩展：
     E S  ->    E E E S 
     N W        N W W W 
按方向N扩展：
       E S 
       N S 
E S -> N S 
N W    N W 
可见，四个方向的扩展会改变原先block中相应的一个格点方向的改变
也会改变当前block中一个格点方向的改变
但是不会影响对应于其它方向的格点的方向。
因此只要按照原图进行dfs扩展即可。如果不能访问所有格点则无解
时间复杂度O(2R*2C)
