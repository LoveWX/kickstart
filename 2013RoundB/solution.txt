Problem A. Sudoku Checker.txt
求(n*n)*(n*n)的数独是否合法
按行、按列、按(n*n)矩阵块计算是否恰好包含[1,n]的数字。

Problem B. Meet and party
平面中点(x1,y1)和点(x2,y2)距离为 |x1 - x2| + |y1 - y2|。用一些矩形圈出平面中的一些点，求其中一个点使得所有点到该点的距离的和最小。
不知道这里的矩形是做什么用的……感觉随便指定点也一样做
对于点{P0,P1,...,Pn-1}，距离和diatance
=(|X1 - Xi| + |Y1 - Yi|) + (|X2 - Xi| + |Y2 - Yi|) + ... + (|Xn-1 - Xi| + |Yn-1 - Yi|)
=(|X1 - Xi| + |X2 - Xi| + ... + |Xn-1 - Xi|) + (|Y1 - Yi| + |Y2 - Yi| + ... + |Yn-1 - Yi|)
也就是说对于一个点，其到其它点的距离和可以在x轴和y轴上分别求。
在x轴上，按x值升序重排各点，则：
Sx0=|X0 - X0| + |X1 - X0| + |X2 - X0| + ... + |Xn-1 - X0|
Sx0=(X0 - X0) + (X1 - X0) + (X2 - X0) + ... + (Xn-1 - X0)
Sx1=(X1 - X0) + (X1 - X1) + (X2 - X1) + ... + (Xn-1 - X1)
可见，可以通过Sx0，依次通过差值求出Sx1,Sx2,...,Sxn-1
一般地，对于 
Sxk  = ... + (Xk   - Xk-1) + (Xk   - Xk) + (Xk+1 - Xk  ) + ...
Sxk+1= ... + (Xk+1 - Xk-1) + (Xk+1 - Xk) + (Xk+1 - Xk+1) + ...
从Sxk到Sxk+1，左半部分每项增加(Xk+1-Xk),项数为(k+1)；右半部分每项增加(-Xk+1+Xk),项数为(n-k-1)
所以Sxk+1 - Sxk = (Xk+1 - Xk)(k+1-n+k+1) = (Xk+1 - Xk)(2k + 2 - n)
即Sxk - Sxk-1 = (Xk - Xk-1)(2k - n)
即可求得每个Sx，同理可求得每个Sy。遍历所有点，求出Sxi + Syi取最小值的点

Problem C. Hex
Hex游戏，在六边形棋盘上红蓝双方轮流下一子，红方联通上下边，蓝方联通左右边则获胜。问给定的棋盘状态是不是可能达到，是哪一方获胜。
1.对棋盘上的棋子计数，差距不能大于1。
2.检查红方是否联通，如果联通，蓝方棋子数不能超过红方。
3.如果红方联通，且红方至少有一个割点，则红方获胜。一方获胜后即停止，联通的一方必须在割点下最后一步棋。
4.检查蓝方是否联通，如果联通，红方棋子数不能超过蓝方。
5.如果蓝方联通，且蓝方至少有一个割点，则蓝方获胜。
6.双方均未获胜
这题用tarjan求割点比较麻烦，这里用的是dfs和并查集两种方法：如果两边联通时去掉一个点使得两边变为不联通，则该点为割点。

Problem D. Dragon Maze
走迷宫，迷宫除了墙以外每个点有一个能量值，求从起点到终点的最短路径中最多能收集到多少能量。
BFS可以求出路径，但是由于要求出能量最大值，直接用queue来做有可能使得某一点因不同能量值反复入队，最差情况是2^n，有这样的用例。
每一步能达到的点集是能够求出的，在点集中按能量从大到小排序，即可在BFS时获得最短路径达到某一点的最大能量。
配合visited矩阵，每一步求得的点集也能够求出下一步的点集。从起点开始找到终点即可，中途队列为空则任务不可能。

Problem E. Ignore all my comments
去除/* */方式的注释，这里/* */可以嵌套，即一个/*不是找第一个*/，而是需要像左括号找右括号一样判断层次。但是去掉注释后如果还出现/* */语句块就不用管了。
找到/*层次+1，找到*/层次-1，层次为0时将字符copy到结果中。
