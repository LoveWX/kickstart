Problem A. Kick_Start
给定一个字符串，求以"KICK"开头且以"START"结尾的字符子串共有多少个
以每个字符为起点尝试匹配"KICK"和"START"
当匹配"KICK"时，计数加1；
当匹配"START"时，前面所有已经匹配的"KICK"都可以作为子串开头，累加到结果中
时间复杂度为O(5N)

Problem B. Maximum Coins
给定一个正方形矩阵，求每个与主对角线平行的斜线上元素的和的最大值
每个斜线逐一求和即可

Problem C. Combination Lock
密码锁有W个锁环，每个锁环有1~N共N个数字，循环连接。
可以花费1代价将1个锁环上的数字加1或减1（注意是循环）
求将所有锁环变为同一个数字的最小代价
锁环的位置不重要，因此可以将初始状态排序
可以选择某一个数字作为目标数字，计算所有锁环变成该数字的总代价
这个目标数字一定是某个锁环的初始数字，否则该数字临近的锁环初始数字也是不坏的解
选择某个目标数字K的最优解中，在K左侧的锁环，一定是靠近K的通过加1方式变为K
远离K的通过减1方式变为K，（因此这里也可以通过二分查找来计算）
在K右侧的锁环同理，由小到大操作先是减1，然后是加1
题目原意是在环状数组，但是可以通过将数组复制并加N的方式，将环状问题展开到一维上
这样就原题就转换为：选择连续的W个锁环，使得它们到其中一个锁环的距离和最小
易见到达这W个锁环中间的那个锁环距离和是最小的
在中心锁环左侧的锁环都通过加1来达到中心锁环，右侧的锁环都通过减1来达到
如果中心锁环左侧一些锁环通过减1可以有更优解，由前述可知，它们一定是这W个锁环的前几个
可以通过平移这W个锁环的方式，将这几个锁环移到右侧对应锁环上去
因此这种情况会在遍历的其它情况中覆盖到
将W个锁环的初始坐标复制2份，以第[W,2W)个锁环为中心锁环，遍历计算所求值
可以通过求出中心锁环的值，再平移的方法求解
时间复杂度O(NlogN+N+N)

Problem D. Merge Cards
有N张牌排成一列，每张牌上写有一个数字Ai
当仍有多于1张牌时，可以进行操作：
选择相邻的两张牌，设其上数字为X和Y，将两张牌合并为一张，数字为X+Y
并获得得分X+Y。
求牌只剩1张时，所获得的积分的数学期望。
单独考虑某一个元素，它在任一一层都存在，只是有可能已经与别的元素合并。
而其对总数学期望的贡献，只与其在某一层的相对位置有关系
可以理解为每层相当于有一些元素已经合并而位置重叠
但是计算数学期望时，每个元素都有概率被选中，因此都对数学期望有贡献
设有i个相邻牌的状态为第i层，
那么首尾元素有1/i的概率被合并而累积到积分中
其它元素有2/i的概率被合并而累积到积分中
可以对每个元素累加它在每层中的概率，再乘该元素的值，就得到了该元素对数学期望的贡献
因此，如果初始时每个元素都是1，就可以求出第i层的i+1个元素各自对积分的数学期望
这种结构是不随着初始数组的改变而改变的。
将初始数组和对应层的每个元素求乘积的和，即可得到总和数组期望
对于第i层（共i+1个元素，编号0~i）的第j个元素而言，
如果它不是首尾元素，那么在该层中，它有2/i的概率被选中
如果选中的是第j个元素自身及前面的相邻对，那么在第i-1层，该元素的下标会减1
如果选中的是第j个元素自身及后面的相邻对，那么在第i-1层，该元素的下标不变
设只有第i层时第j个元素对总数学期望的贡献为dp[i][j]
因此对于第i层的首元素，dp[i][0]=1/i+dp[i-1][0]
对于第i层的尾元素，dp[i][i]=1/i+dp[i-1][i-1]
对于第i层的其它元素,dp[i][j]=2/i+j/i*dp[i-1][j-1]+(i-j)/i*dp[i-1][j]
可以求出该结构之后，再将每个输入的数组与对应的层正交求解
时间复杂度为O(N*N)
