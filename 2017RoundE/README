Problem A. Trapezoid Counting
给定一些整数数组表示的小棍棒，求能够组成等腰梯形的四棍棒集合的个数。下标不同的棍棒即认为不同。梯形由四元素集合表示，不区分顺序。
设梯形腰长为e，短底边为a，长底边为b，则有0<b-a<2e
如果长度为e的棍棒只用两个，那么遍历a，有a<b<a+2e，累计长度在(a,a+2e)范围内的棍棒数即可。注意如果a<e<a+2e，则需要去掉长度为e的棍棒。
如果长度为e的棍棒用了三个，那么遍历a，有0<e-a<2e or 0<a-e<2e，即0<a<e or e<a<3e，那么累计长度在(0,3e)范围内的棍棒数，减去去掉长度为e的棍棒数即可。

Problem B. Copy & Paste
需要从特定编辑器中输出给定字符串的最少操作数。编辑器只有三种操作：1.输出一个字母；2.复制已输出字符串的任一子串到剪贴板；3.输出剪贴板的全部内容。
1.如果只需要输出一个字母，那么直接键入比从剪贴板复制操作更少
2.只能复制已有字符串的子串，说明“复制”这种操作是和已有状态相关的，所以可以用DP解决，目前已输出的字符串是状态的一维。
  设字符串已经输出到下标idx的位置，需要的最小操作数为dp1(idx)
3.对于已输出的字符串s[0,idx]而言，最后一次输出的长度可能是[1,idx+1]的一种。所以可以以最后一次输出的起点为另一维。
  设s[0,idx]最后一次输出的字符串为s[left,idx]，则可以根据s[0,left-1]中是否包含与s[left,idx]相同的子串来分类讨论。
  设dp2(left,idx)表示已经输出字符串s[0,idx]，且最后一次输出字符串为s[left,idx]的最小操作数
4.可见dp2(i)需要从dp1(j),j<i和dp2(k,i-1),k<i-1中计算得到。这样也得到了DP的状态转移。
5.对于某个最后一次输出字符串s[left,idx]而言，单独计算前面已经出现的相同子串很不方便，所以可以先统一计算出相同字符串出现的位置。
基本步骤：
1.按长度枚举可能出现的子串，对于每一种子串，记录每次出现的始末位置。
  这里的主要目的是找到相同的子串出现的始末位置，具体子串是什么并不重要。所以可以将同一子串的位置按出现顺序记录在位置数组vector<pair<>>中，
  再用一个矩阵记录下每种始末位置的子串是对应哪个位置数组的哪个元素，这样就能通过子串始末位置查到其左侧的所有相同子串。
  共有O(n)种长度，每种长度有O(n)个子串，用map归类相同子串需要O(nlogn)，共计需要O(n^2 logn)的时间进行预处理。
  注意这里不需要处理长度为1的子串，和长度超过n/2的子串。
2.对于已输出的字符串s[0,idx]，其操作数为各种可能操作(最后一次各种长度输出)的最小值，即dp1(idx)=min(dp2(*,idx))
3.对于已经输出字符串s[0,idx]，且最后一次输出字符串为s[left,idx]的情况，需要查看子串s[left,idx]是否已经出现在s[0,left-1]中
  设s[0,left-1]中第一次出现s[left,idx]为子串s[i0,j0]，最后一次出现为子串s[ik,jk]，则：
3.1.如果子串s[i0,j0]不存在，即s[0,left-1]不包含s[left,idx]，则最后一次输出不能为s[left,idx]，即dp2(left,idx)=INT_MAX
3.2.如果s[i0,j0]==s[ik,jk]，即s[0,left-1]包含一个s[left,idx]，
    说明可以在输出s[0,left-1]后，复制s[i0,j0]，再粘贴的方式获得s[0,idx]，此时dp2(left,idx)=dp1(left-1)+2
3.3.如果s[i0,j0]!=s[ik,jk]，即s[0,left-1]包含多于一个s[left,idx]。
    遍历每个s[i0,j0],...,s[ik,jk]，将其作为最后一个整体输出，
	这样输出完s[0,left-1]后，可以直接粘贴s[left,idx]得到s[0,idx]。而s[j+1,left-1]中的字符就只能依次键入了。
	除了s[i0,j0]适用3.2.处理，其它情况下dp2(left,idx)=dp2(i,j)+(left-j-1)+1
共计O(n)个位置和O(n^2)个最后一次长度，每个最后一次长度需要遍历O(n)个相同子串，总计需要O(n^3)时间。

Problem C. 
