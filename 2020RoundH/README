Problem A. Retype
游戏有N层，现在在第K层，需要到第S层拾取特定道具，S<K。
可以有两种选择：要么从第1层开始重打；要么从第K层打到第S层，再打到第N层
求最少需要打多少层
直接计算两种选择需要打多少层并比较即可

Problem B. Boring Numbers
设一个数字最高位为第1位，其低位依次为第2位，第3位...
如果一个数字奇数位上的数字为奇数且偶数位上的数字为偶数，则为"无聊数"
给定L和R，求[L,R]范围中的无聊数的个数
解1：可以用数位DP来做。需要将当前位是奇数位还是偶数位用state表示
注意数的最高位为第1位，因此需要用leading来记录当前状态是不是有前导0
当前位有前导0时，需要1.将前导0累积到下一位，这对应更少数位的数字
2.以当前位为最高位计算
当前位无前导0时，按数位dp方法正常计算
解2：如果没有范围限制，那么每个数位有5种选择
需要从高位到低位依次遍历，累乘每位可能的情况数即可

Problem C. Rugby
在平面上给定N个点的坐标（整数点），每个点可以以1的代价移动到相邻的整数点上。
如果在平面上将这N个点排成一排，即每个点y值一样，但是x值是N个连续的数
求达到这种状态的最小代价
X轴上移动和Y轴上移动互相不干扰，因此可以分开处理
对于Y轴来说，相当于是求将这些点移到一起的最小代价，那么直接移动到中心点即可
对于X轴来说，每个点从初始状态到结束状态的移动过程中，不会越过其它点
而结束状态中相邻两个点需要X轴坐标差1
那么可以为初始状态下每个点减去下标作为补偿，这样就转换为类似X轴的题目求解了
更正式地说：如果设X轴所有点X1,X2,...,XN的中间点为Xm，
由于在X轴移动过程中每个点都不会越过其它点，可以用反证法证明存在最优解使得Xm不移动
（如果N为奇数，则Xm不移动为唯一最优解；若N为偶数，则中间的两个点间都可以作为新的最优中点）
那么其它点的移动距离为abs(Xi-(Xm-m+i))，移动距离总和为sigma(abs(Xi-(Xm-m+i)))
时间复杂度O(NlogN)

Problem D. Friends
给定N个人的名字Si，如果两人名字中有相同的字母，则这两人是朋友
如果两人通过朋友的朋友连接在一起，那么他们两人和这些朋友组成的路径叫"朋友链"
给定特定的两人，求他俩之间朋友链的长度最小是多少
将每个字母认为是点，每个字符串认为是边，
一个字符串中所有的字符对都以这个字符串为边直接连在一起
这样求字符串的距离就转换为字符的距离
可以先以每个字符为源，求出它到其它字符的最短距离
对每个提问中的两个字符串，枚举所有的字符对，求出最短距离
字符串的最短距离等于字符对最短距离加2
