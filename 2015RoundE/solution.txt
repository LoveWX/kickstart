Problem A. Password Attacker


Problem B. New Years Eve


Problem C. Card Game


Problem D. Sums of Sums
给定N个正整数组成的数组，由其N*(N+1)/2个子数组的和组成新数组并升序排列，求新数组中第L小的元素到第R小的元素的和。
这个问题的难点在于N很大，不能求出新数组后再计算元素和。
子数组的和即数组区间和，可以由前缀和得到。而子数组和的和，可看做固定数组一端后，得到的所有子数组的前缀和的前缀和。
可以通过类似于树状数组区间查询的方法通过记录前缀和以及辅助数组来实现
设数组a为：
a:a[1],a[2],...,a[i]
其前缀和数组p为：
p:p[1],p[2],...,p[i]
p[1]=a[1]
p[2]=a[1]+a[2]
...
p[i]=a[1]+a[2]+...+a[i]
其前缀和的前缀和数组s为：
s:s[1],s[2],...,s[i]
s[1]=p[1]
s[2]=p[1]+p[2]
...
s[i]=p[1]+p[2]+...+p[i]
    =(a[1])+(a[1]+a[2])+...+(a[1]+a[2]+...+a[i])
    =i*a[1]+(i-1)*a[2]+...+1*a[i]
    =(i+1)(a[1]+a[2]+...+a[i])-(1*a[1]+2*a[2]+...+i*a[i])
记数组d为:
d:d[i]=1*a[1]+2*a[2]+...+i*a[i]
这样，对于原数组a，记录下前缀数组p和数组d，即可对给定的区间快速求子数组和的和。
假设需要求原数组区间[left,right]以left为左端的子数组的和的和S
S=a[left]+(a[left]+a[left+1])+...+(a[left]+a[left+1]+...+a[right])
 =(p[left]-p[left-1])+(p[left+1]-p[left-1])+...+(p[right]-p[left-1])
 =(p[left]+p[left+1]+...+p[right])-(right-left+1)*p[left-1]
 =(s[right]-s[left-1])-(right-left+1)*p[left-1]
 =(right+1)*p[right]-d[right]-(left-1+1)*p[left-1]+d[left-1]-(right-left+1)*p[left-1]
 =(right+1)(p[right]-p[left-1])-(d[right]-d[left-1])
1.求对于给定的排名K，在新数组中对应的值是多少，即求新数组中第K小的值Kval。
可以由二分法尝试可能的值，来找到第K小的值。
先固定子数组的一端，求在给定的和值时，最长子数组的另一端在哪里，从而计算出所有和值小于(等于)指定值的子数组的个数。
这里可以用二分法，也可以用滑动窗口。二分法即对于每个左端，找到最右的右端；滑动窗口需要对于每个左端收缩右端。
注意这里固定左端还是右端，需要和上述求S的过程相匹配。
2.求出原数组中小于Kval的所有子数组和的和以及个数，即新数组中小于Kval的值之和以及元素个数。再加上剩余几个Kval，得到新数组中前K小值之和。
由于新数组中可能出现重复元素，所以不能直接求新数组小于等于Kval的值之和，该值不同于新数组中前K小值之和。
3.求两次新数组中前K小值之和，做差得到结果
