Problem A. 

Problem B. 


Problem C. Funniest Word Search
给定一个单词词典和字母矩阵，如果矩阵的某一行从左到右包含某个单词，那么该单词匹配一次。
某一行从右到左、某一列从上到下和从下到上同理，单词匹配数需要重复计算。
矩阵“有趣度”定义为：矩阵匹配所有单词的总长度/(矩阵高+矩阵宽)。
求给定的字母矩阵所有的子矩阵中，求最大的“有趣度”，以及有多少个子矩阵“有趣度”是该最大值。
1.单词从右至左相当于字典中包含所有原单词的逆序单词，从上到下和从下到上同理。需要O(sumWordsLength)时间。
2.对于字母矩阵每一行，可以找到所有单词出现的首尾坐标。按尾坐标排序。需要O(C*sumWordsLength)时间
这样对于固定的首坐标，可以求得在尾坐标右移一位时，匹配单词总长度增加了多少。
对于每个首坐标，求出每个尾坐标表示的一段所覆盖的匹配单词总长度，记录在rowVal中，
rowVal[r][i][j]表示第r行第i列到第j列的一段字符，从左到右和从右到左，所覆盖的匹配单词总长度。需要O(C*(C+1)/2)时间。
总计需要O(R*C*C+R*C*sumWordsLength)的时间
3.对于字母矩阵的每一列，同理求得colVal[c][i][j]。
4.题目要求最大“有趣度”有多少子矩阵达到，所以需要恰好遍历每个子矩阵一次。
固定子矩阵左上角，每行每列依次遍历子矩阵右下角，可以求得对应长宽的子矩阵的匹配单词总长度。
需要记录固定子矩阵左上角时，已经求出的右下角的子矩阵的匹配单词总长度。
      y0    ...    y1-1    y1
x0     A    ...      B      C
...                          
x1-1   D             E      F
x1     G             H      I
例如：子矩阵左上角固定为(x0,y0)，求子矩阵右下角为(x1,y1)时匹配单词总长度。
子矩阵ACIG可以看做由子矩阵ABED向右延伸为ACFD，再向下延伸为ABHG，
再在第x1行从GH延伸到GI，再在第y1列从第CF延伸到CI。
这样，利用已经求出的结果和结果之间的差值，可以求得子矩阵ACIG的结果。
m[x1][y1]=m[x1-1][y1]+m[x1][y1-1]-m[x1-1][y1-1]
                     +rowVal[x1][y0][y1]-rowVal[x1][y0][y1-1]
                     +colVal[y1][x0][x1]-colVal[y1][x0][x1-1]
这样可以在O(R*C)时间求解。这样的子矩阵左上角共计O(R*C)个，所以需要O(R^2*C^2)的时间
