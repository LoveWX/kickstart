Problem A. Longest Arithmetic
给定数组A，从A中找到一个子数组，使得该子数组成为一个等差数列且长度最大。
直接计算数组A的差值数组，找到最长的相同元素组成的子数组即可。

Problem B. High Buildings
直线上有一些建筑物，从一侧看去时，如果没有被更高的建筑物挡住，就可以被这一侧的观察者看到
现在给出两侧观察者看到的建筑物的数量A,B，已经被两侧观察者看到的数量C，求一个给定的建筑物高度序列。
至少有一个建筑物被双方看到，因此C>0，可以设置中间长度为C的一段为最高高度N，
左侧应该有A-C个建筑，可以设置高度为N-1；右侧应该有B-C个建筑，可以设置高度为N-1。
如果A-C+C+B-C>N，说明不可能。
否则将多出来的N-(A-C+C+B-C)个建筑设置高度为1，加在有建筑多出的一侧中间使其不被看见即可。

Problem C. Toys
N个玩具排成一圈，Axel从第一个玩具开始依次玩每个玩具。
给出Axel玩每个玩具的时间E[i]，以及Axel停止玩某个玩具后多长时间R[i]会忘记这个玩具。
如果Axel玩到某个已经玩过的玩具且他还没有忘记的话，整个过程停止。
也有可能Axel可以一直在圈中玩下去。
求Axel最长可以玩多长时间，以及此时需要最少从圈中去掉多少个玩具。
每个玩具至少会被Axel玩一次，第二圈时才有可能停在某个玩具处。
设圈中玩具能拖住Axel的总时间为sumE，第一轮时所有的玩具都会被计算
对于每个玩具而言，需要满足记忆时间小于其它玩具总耗时，即:sumE-E[i]>=R[i]
那么需要从圈中去掉那些不满足条件的玩具，即E[i]+R[i]>sumE的玩具。
需要注意的是，这些满足E[i]+R[i]>sumE的玩具需要全部去掉，
因为去掉其中某一个玩具之后，会导致sumE减小，而对其它玩具而言E[i]+R[i]的值不变。
更进一步地，去掉这些玩具之后，会导致其它玩具从sumE-E[i]>=R[i]状态变为E[i]+R[i]>sumE的状态，从而也需要去掉
考虑这些新出现的需要去掉的玩具。
对于其中某一个玩具而言，需要去掉是因为受自身影响的E[i]+R[i]值不变，而受其它玩具影响的sumE值却在减少
那么其中E[i]+R[i]值更大的玩具更有可能被去掉。
因此从N个玩具中依次挑出E[i]+R[i]最大的玩具，直到剩下的玩具E[i]+R[i]<=sumE为止。
如果有剩下的玩具，说明Axel可以一直玩这些玩具。
而如果不能一直玩下去，那么需要按照这些玩具原先的顺序考虑第二轮的情况。
设sum1为第一轮中玩具的总时间，sum2为第二轮目前已访问的玩具的总时间。
当第二轮遇到一个玩具k时，从之前遇到的所有玩具中取出E[i]+R[i]>sum1的一个玩具，
直到剩下所有玩具满足E[i]+R[i]<=sum1，当然也可能不需要取出玩具。注意sum1和sum2都需要同步更新。
这样就得到了到玩具[1,k]玩的时间最长时的解。依次遍历每个玩具，找到玩的时间最长的解。
遍历需要的时间为O(N)，但是需要堆来获取E[i]+R[i]最大的玩具，因此总时间复杂度为O(NlogN)

Problem D. Golden Stone
无向图中共有N个结点M条边，共有S种石头，无向图中的结点可以无限提供某些种类的石头。第一种石头是金块
将一个石头通过无向图的边运送到相邻的结点需要1能量。
有R个配方可以合成石头，只要同时满足配料表中的每种成分含量。
求合成1个金块最少需要的能量。
注意到N<=300,S<=300，可以记录下在每个结点获得某种石头需要的最少能量
然后可以采用类似于最短路径的方法来求解。
只考虑运输，那么可以用BFS或者类似方法求出某结点某石头的最少能量，像一个多源点求距离的问题一样
当然也可以用Dijkstra算法，类似于最短路径。因为“每次只更新最近的结点”这一性质BFS通过入队顺序来保证，
而本题还需要处理配方的情况，可能会向队列中插入更近距离的结点，因此需要使用优先队列
在每个结点还遍历每种石头，查看是否可以通过某种配方得到这种石头。
优先队列中按照所需能量先出队最小能量结点，因此总体而言会先更新运输得到的石头，然后是通过配方产生的石头
能产生更小能量的结点会继续优先传播(指入队并优先出队)，因此可以更新全部结点。
运输方法共有N*S个结点，因此需要O((NS+MS)log(NS))时间；而每个结点需要遍历所有配方，因此需要O(NR)时间
总时间复杂度为O((N*S+M*S)log(N*S)+N*R)
